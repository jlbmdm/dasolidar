# -*- coding: utf-8 -*-
'''
/***************************************************************************
 Dasoraster
                                 A QGIS plugin
 Herramientas para trabajar con rastes dasométricos
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-27
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Jose Bengoa
        email                : dasolidar@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
'''

import os
import sys
import math
import time
from datetime import datetime
import platform
import subprocess
import pandas as pd

import numpy as np
import win32com.client
# from osgeo import gdal
# import psutil

# imports de plugin builder
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *

from .dasoraster_dialog import DasorasterDialog, DasorasterDialog_consulta_rodal

# Imports extras
from qgis.utils import iface
from qgis.core import (
    Qgis,
    # QgsApplication,
    # QgsMessageLog,
    QgsGeometry,
    QgsProject,
    QgsSettings,
    QgsVectorLayer,
    QgsRasterLayer,
    QgsRectangle,
    QgsPointXY,
    QgsWkbTypes,
    QgsPointCloudLayer,
    QgsLayerTreeGroup,
    QgsLayerTreeLayer,
    # QgsSpatialIndex,
    QgsFeatureRequest,
    QgsCoordinateTransform,
    QgsCoordinateReferenceSystem,
    QgsMapLayer,
    QgsRasterBandStats,
    QgsRaster,
    QgsVectorFileWriter,
    QgsFeature,
)

from qgis.gui import (
    QgsMapToolEmitPoint,
    QgsRubberBand,
    QgsMapToolIdentifyFeature,
    # QgsMapToolIdentify,
)

from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtGui import (
    QColor,
    QCursor,
    QPixmap,
    QPainter,
    QPen,
)
from qgis.PyQt.QtWidgets import (
    QTextBrowser,
    QLabel,
    QDialogButtonBox,
    QTextEdit,
    QAction,
    QMessageBox,
    # QFrame,
    # QSpacerItem,
    # QSizePolicy,
    # QGridLayout,
    # QDialog,
    # QVBoxLayout,
    # QLineEdit,
    # QCheckBox,
    # QPushButton,
    # QHBoxLayout,
    # QMainWindow,
    # QWidget,
)

from PyQt5.QtWidgets import (
    QApplication,
    QFormLayout,
    QDialog,
    QVBoxLayout,
    QLineEdit,
    QCheckBox,
    QPushButton,
    QMainWindow,
    QComboBox,
    # QWidget,
)
from PyQt5.QtCore import (
    QUrl,
    pyqtSignal,
    QTimer,
    # QObject,
)
from PyQt5.QtGui import QDoubleValidator

# imports para la descarga de lasFiles
# from qgis.core import QgsMessageLog
# from PyQt5.QtWidgets import QMessageBox
# from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox
# from qgis.PyQt.QtGui import QDesktopServices
# from qgis.PyQt.QtCore import QUrl
# from qgis.core import QgsFeature
# from PyQt5.QtWidgets import QInputDialog, QLineEdit

# ==============================================================================
# RECORDATORIO: Actualizar el fichero resources.qrc si cambio o muevo iconos
# Si cambio el resources.qrc debe compilarse de nuevo en shell de OSGeo4w, desde la ubicación del complemento:
#    D:\_clid\dasolidar\dasolidar\dasoraster>pyrcc5 -o resources.py resources.qrc
# Contenido actual de resources.qrc:
'''
<RCC>
    <qresource prefix="/plugins/dasoraster" >
        <file>resources/images/icon_dasolidar.png</file>
        <file>resources/images/icon_parcela.png</file>
        <file>resources/images/icon_rodal.png</file>
        <file>resources/images/icon_explorer.png</file>
        <file>resources/images/icon_guiaRapida.png</file>
        <file>resources/images/icon_book.png</file>
        <file>resources/images/icon_star.png</file>
        <file>resources/images/icon_config.png</file>
        <file>resources/images/icon_arbol.png</file>
    </qresource>
</RCC>
'''
# ==============================================================================
# Si da error al descargar el complemento, estas pueden ser las causas:
# El error que estás viendo al intentar desinstalar el complemento de QGIS indica que hay un problema al intentar acceder a la clave del complemento 'dasoraster'. Aquí hay algunas posibles causas y soluciones:
# Posibles Causas
# 1. Problemas en el archivo metadata.txt:
# Asegúrate de que el archivo metadata.txt de tu complemento esté correctamente configurado. Verifica que el nombre del complemento y otros campos estén bien definidos.
# Archivos faltantes o corruptos:
# Puede que algunos archivos del complemento se hayan perdido o estén corruptos. Esto puede causar que QGIS no pueda encontrar el complemento al intentar desinstalarlo.
# Problemas de caché:
# A veces, QGIS puede tener problemas con la caché de los complementos. Esto puede causar que el complemento no se desinstale correctamente.
# 4. Dependencias no resueltas:
# Si tu complemento depende de otros complementos o bibliotecas que no están disponibles, esto puede causar problemas al intentar desinstalarlo.
# -> Siempre puedo haceresto manualmente:
# Eliminar manualmente el complemento:
#   Si el complemento no se desinstala correctamente, puedes intentar eliminarlo manualmente. Ve a la carpeta de complementos de QGIS (normalmente en C:\Users\<tu_usuario>\AppData\Roaming\QGIS\QGIS3\profiles\default\python\plugins\) y elimina la carpeta correspondiente a tu complemento (dasoraster).
# Limpiar la caché de complementos:
#   Puedes intentar limpiar la caché de complementos de QGIS. Esto se puede hacer cerrando QGIS, y luego eliminando el contenido de la carpeta de caché de complementos (normalmente en C:\Users\<tu_usuario>\AppData\Roaming\QGIS\QGIS3\profiles\default\python\plugins\__pycache__).
# ==============================================================================
                                                                                                                                                                     
PLUGIN_DIR = os.path.dirname(__file__)

ruta_codelists_local1 = PLUGIN_DIR
ruta_codelists_local2 = os.path.join(PLUGIN_DIR, 'dasoraster')
metadata_filepath = os.path.join(ruta_codelists_local1, 'metadata.txt')
if not os.path.exists(metadata_filepath):
    print(f'betaraster-> No se encuentra: {metadata_filepath}')
    metadata_filepath = os.path.join(ruta_codelists_local2, 'metadata.txt')
__version__ = '0.0.0'
if os.path.exists(metadata_filepath):
    metadatos_leidos = False
    try:
        with open(metadata_filepath, mode='r', encoding='utf-8') as my_list:
            lista_metadata = my_list.readlines()
        metadatos_leidos = True
    except:
        print(f'betaraster-> Error al leer los metadatos 1: {metadata_filepath}')
        try:
            with open(metadata_filepath, mode='r', encoding='cp1252') as my_list:
                lista_metadata = my_list.readlines()
            metadatos_leidos = True
        except:
            print(f'betaraster-> Error al leer los metadatos 2: {metadata_filepath}')
    if metadatos_leidos:
        try:
            for mi_sp in lista_metadata:
                list_sp = (mi_sp.rstrip('\n')).split('=')
                if list_sp[0] == 'version':
                    __version__ = list_sp[1]
                    print(f'betaraster-> Metadatos leidos ok. Version dasoraster: {__version__}')
                    break
        except:
            print(f'betaraster-> Error al leer los metadatos 3: {lista_metadata}')
else:
    print(f'betaraster-> No se encuentra: {metadata_filepath}')

# print(f'betaraster-> plugin_dir: {PLUGIN_DIR}')
try:
    mi_PYTHONPATH = os.environ['PYTHONPATH']
except:
    mi_PYTHONPATH = 'No disponible'
if PLUGIN_DIR not in sys.path:
    sys.path.append(PLUGIN_DIR)
print(f'betaraster-> PYTHONPATH: {mi_PYTHONPATH}')
print(f'betaraster-> sys.path:   {sys.path}')

try:
    from dasoutil import calcular_valor_medio_parcela_rodal, identifica_especies_mfe, leer_csv_codigos1, leer_csv_codigos3
    # from dasoutil import identifica_especie, leer_raster_float, leer_csv_codigos2
    # from dasoutil import identificar_usuario
except:
    print(f'betaraster-> No se ha podido instalar el complemento.')
    iface.messageBar().pushMessage(
        title='dasoraster',
        text='Parece que este PC o este proyecto Lidar tiene dificultades para ejecutarse correctamente.'\
             '\n Puede deberse a que no tiene acceso a la ubicación de red del proyecto dasolidar.'\
             '\nEs posible que no se esté ejecutando dentro de la JCyL o el usuario no esté dado de alta en el proyecto.',
        showMore=f'Si eres técnico de medio ambiente de la Junta de Castilla y León y estás trabajando con un PC dentro de la Junta y quieres tener acceso a este recurso\nEnvía un correo electrónico siguiendo las instrucciones que figuran en la guia de primeros pasos y en el manual de consulta.',
        duration=30,
        level=Qgis.Warning,
    )
    sys.exit(1)
# usuario_actual = identificar_usuario()

try:
    # usuario_psutil = psutil.users()[0].name
    # usuario_psutil = psutil.users()
    usuario_env = ''
    usuario_profile = ''
    try:
        usuario_login = os.getlogin()
        print(f'betaraster-> Usuario_login ({type(usuario_login)}): {usuario_login}')
    except:
        usuario_login = None
        try:
            usuario_env = os.environ.get('USERNAME')
            print(f'betaraster-> Usuario_env ({type(usuario_env)}): {usuario_env}')
        except:
            usuario_env = None
            usuario_profile = os.path.expandvars('%userprofile%')[-8:].lower()
            print(f'betaraster-> Usuario_profile: {usuario_profile}')
    if isinstance(usuario_login, str) and len(usuario_login) == 8:
        usuario_actual = usuario_login.lower()
    elif isinstance(usuario_env, str) and len(usuario_env) == 8:
        usuario_actual = usuario_env.lower()
    elif isinstance(usuario_profile, str) and len(usuario_profile) == 8:
        usuario_actual = usuario_profile.lower()
    elif isinstance(usuario_login, str):
        usuario_actual = usuario_login.lower()
    elif isinstance(usuario_env, str):
        usuario_actual = usuario_env.lower()
    elif isinstance(usuario_profile, str):
        usuario_actual = usuario_profile.lower()
    else:
        usuario_actual = 'anonimo'
except:
    usuario_actual = 'anonimo'
print(f'betaraster-> usuario_actual: {usuario_actual}')

GRUPO_LIDAR_DESCARGADO = 'lidarDescargado'
DIMENSION_BLOQUE = 2000
AUTOCARGA_ESCALA_MAXIMA_RECOMENDADA = 10000
AUTOCARGA_ESCALA_MAXIMA_PERMITIDA = 30000
EMAIL_DASOLIDAR1 = 'dasolidar@gmail.com'
EMAIL_DASOLIDAR2 = 'benmarjo@jcyl.es'
SEP_CSV_INPUT = '\t'
SEP_CSV_OUT = '\t'
SEP_CSV_DSLD = '\t'
VERBOSE = False

aux_path_new = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\varios\.aux'
scripts_path = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\varios\scripts'
lista_usuarios_actual_filename = os.path.join(aux_path_new, 'usuarios/usuariosLidar_versionActual.csv')
lista_usuarios_beta_filename = os.path.join(aux_path_new, 'usuarios/usuariosLidar_versionBeta.csv')
if os.path.exists(lista_usuarios_beta_filename):
    try:
        with open(lista_usuarios_beta_filename, mode='r', encoding='utf-8') as my_list:
            listaUsers_versionBeta = my_list.readlines()
            listaId332_versionBeta = [usuario.split(SEP_CSV_DSLD)[0].lower() for usuario in listaUsers_versionBeta]
        # print(f'betaraster-> Encoding UTF8 ok')
    except:
        try:
            with open(lista_usuarios_beta_filename, mode='r', encoding='cp1252') as my_list:
                listaUsers_versionBeta = my_list.readlines()
                listaId332_versionBeta = [usuario.split(SEP_CSV_DSLD)[0].lower() for usuario in listaUsers_versionBeta]
            # print(f'betaraster-> Encoding cp1252 ok')
        except:
            print(f'betaraster-> Atencion: revisar caracteres no admitidos en {lista_usuarios_beta_filename}')
            listaId332_versionBeta = []
else:
    listaId332_versionBeta = []

if usuario_actual in listaId332_versionBeta:
    usuario_alfa = True
else:
    usuario_alfa = False

clave_uso_version = f'dasolidar/uso_dasoraster_v.{__version__}'
mi_config = QgsSettings()

class Configuracion():
    def __init__(self):
        self.dl_usos = mi_config.value(clave_uso_version, 0)
        try:
            num_usos = int(self.dl_usos)
        except:
            num_usos = 0
        mi_config.setValue(clave_uso_version, num_usos + 1)

        # Esto no lo uso. El usuario lo obtengo de os.getlogin() o de os.environ.get('USERNAME') y no de QgsSettings
        self.dl_usuario = mi_config.value('dasolidar/usuario', usuario_actual)
        # Esto no lo uso. La opción de mostrar ventana de bienvenida la dejo para el script de arranque
        self.dl_mostrar_ventana_bienvenida = mi_config.value('dasolidar/mostrar_ventana_bienvenida', True)
        self.dl_mostrar_message_bienvenida = mi_config.value('dasolidar/mostrar_message_bienvenida', True)

config_class = Configuracion()
print(f'betaraster-> Uso de la version {__version__}: {config_class.dl_usos}')



dict_especies = {
    'Ps': 'Pinus sylvestris',
    'Pn': 'Pinus nigra',
    'Pt': 'Pinus pinaster',
    'Pp': 'Pinus pinea',
    'Ph': 'Pinus halepensis',
    'Pr': 'Pinus radiata',
    'Pu': 'Pinus uncinata',
    'Qp': 'Quercus pyrenaica',
    'Qi': 'Quercus ilex',
    'Qf': 'Quercus faginea',
    'Qt': 'Quercus petraea',
    'Qr': 'Quercus robur',
    'Qs': 'Quercus suber',
    'Fs': 'Fagus sylvatica',
    'Lq': 'Populus spp de produccion',
    'Xx': 'Otra especie',
    'Lg': 'Populus nigra',
    # 'La': 'Populus alba',
    # 'Jt': 'Juniperus thurifera',
    # 'Jo': 'Juniperus oxycedrus',
    # 'Cs': 'Castanea sativa',
    # 'Ag': 'Alnus glutinosa',
    # 'Ba': 'Betula alba',
    # 'Fa': 'Fraxinus angustifolia',
    # 'Au': 'Arbutus unedo'
}

dict_cod_variables_dasometricas = {
    'VCC': ['Volumen de madera (fustes)', 'm3/ha'],
    'DCM': ['Diámetro medio (cuadrático)', 'cm'],
    'Npies': ['Número de pies por hectárea (densidad)', 'pies/ha'],
    'Abas': ['Área basimétrica', 'm2/ha'],
    'IAVC': ['Crecimiento anual en volumen', 'm3/ha.año'],
    'BA': ['Biomasa aérea', 't/ha'],
    'VLE': ['Volumen de leñas', 'm3/ha'],
    'Hdom': ['Altura dominante lidar (es una métrica lidar)', 'm'],
}
dict_capas_variables_dasometricas = {
    'VolumenMadera_m3_ha': 'VCC',
    'DiamMed_cm': 'DCM',
    'NumPies_ha': 'Npies',
    'AreaBasimetrica_m2_ha': 'Abas',
    'CrecimientoVolumenMadera_m3_ha.año': 'IAVC',
    'BiomasaAerea_t_ha': 'BA',
    'VolumenLeñas_m3_ha': 'VLE',
    'AlturaDominanteLidar_m': 'Hdom',
}
dict_cod_variables_dasometricas_inverso = {}
for key, variable_dasometrica in dict_cod_variables_dasometricas.items():
    dict_cod_variables_dasometricas_inverso[variable_dasometrica[0]] = key


dict_spp_mfe25cyl = leer_csv_codigos1()
# lista_dict_codigos_especies =  leer_csv_codigos2()
# (dict_cod2L_nSP, dict_nSP_cod2L, dict_esp_cod2l_equi, dict_esp_nsp_equi) = lista_dict_codigos_especies
lista_dict_codigos_estratos =  leer_csv_codigos3()
(dict_zonas, dict_fechas, dict_cod_modelo) = lista_dict_codigos_estratos

mis_variables_codigo = []
mis_variables_nombre = []
mis_variables_unidad = []
for key, variable_dasometrica in dict_cod_variables_dasometricas.items():
    mis_variables_codigo.append(key)
    mis_variables_nombre.append(variable_dasometrica[0])
    mis_variables_unidad.append(variable_dasometrica[1])
mis_variables_unidad.append('Otra')
print('mis_variables_unidad', mis_variables_unidad)


def mensaje(mi_text='', mi_title='dasoraster', mi_showMore=None, mi_duration=15, mi_level=Qgis.Info):
    if mi_showMore is None or type(mi_showMore) != str:
        iface.messageBar().pushMessage(
            title=mi_title,
            text=mi_text,
            duration=mi_duration,
            level=mi_level,
        )
    else:
        iface.messageBar().pushMessage(
            title=mi_title,
            text=mi_text,
            showMore=mi_showMore,
            duration=mi_duration,
            level=mi_level,
        )

def capa_malla_lasfiles():
    layer_selec = QgsProject.instance().mapLayersByName('cargar_nubeDePuntos_LidarPNOA2')
    if not layer_selec:
        print(f'betaraster-> La capa "cargar_nubeDePuntos_LidarPNOA2" no está cargada en el proyecto.')
        iface.messageBar().pushMessage(
            title='dasoraster',
            text='Para hacer la descarga de ficheros lidar de nubes de puntos (lasFiles) se requiere que la capa cargar_nubeDePuntos_LidarPNOA2 esté cargada en el proyecto. Pulsa el botón [mostrar más] y vuelve a intentarlo.',
            showMore=f'Este complemento está preparado para trabajar con el proyecto LidarQgis.\n'\
                'Si estás trabajando con un proyecto tuyo es posible que éste no tenga la capa cargar_nubeDePuntos_LidarPNOA2 (malla para descarga de fichero lidar).\n'\
                'A continuacón se va a intentar cargar esa capa desde la ubicación de red: //repoarchivohm.jcyl.red/MADGMNSVPI_SCAYLEVueloLIDAR$/PNOA2/.aux/lidar_copc.gpkg|layername=copc.\n'\
                'Para eso necesitas tener acceso a esa ubicación de red, para lo cual debes estar dado de alta en la lista de usuarios dasolidar.\n'\
                'Para saber si estás dado de alta puedes enviar esta consulta con el botón "Consultas & IA" de este complemento dasoraster.\n'
                'Si tiene éxito la carga automática esa capa en el proyecto; una vez hecho vuelve a intentar la carga del fichero lidar (nube de puntos)',
            duration=20,
            level=Qgis.Warning,
        )

        # Ruta al archivo de la capa
        aux_path = r'\\repoarchivohm.jcyl.red/MADGMNSVPI_SCAYLEVueloLIDAR$/PNOA2/.aux'
        if not os.path.isdir(aux_path):
            iface.messageBar().pushMessage(
                title='dasoraster',
                text='Parece que este PC no tiene acceso a la ubicación de red con la información de descarga de nubes de puntos ({aux_path}).'\
                     '\nEs posible que no se esté ejecutando dentro de la JCyL o el usuario no esté dado de alta.',
                showMore=f'Si eres técnico de medio ambiente de la Junta de Castilla y León y estás trabajando con un PC dentro de la Junta y quieres tener acceso a este recurso\nEnvía un correo electrónico siguiendo las instrucciones que figuran en la guia de primeros pasos y en el manual de consulta.',
                duration=30,
                level=Qgis.Warning,
            )
            return False, None
        file_path = r'\\repoarchivohm.jcyl.red/MADGMNSVPI_SCAYLEVueloLIDAR$/PNOA2/.aux/lidar_copc.gpkg|layername=copc'
        # Creo la capa
        layer_selec = QgsVectorLayer(file_path, 'cargar_nubeDePuntos_LidarPNOA2', 'ogr')
        # Verifico si la capa es válida y la agrego al proyecto
        if layer_selec.isValid():
            QgsProject.instance().addMapLayer(layer_selec)
            print(f'betaraster-> La capa "cargar_nubeDePuntos_LidarPNOA2" ha sido cargada.')
            iface.messageBar().pushMessage(
                'Capa cargar_nubeDePuntos_LidarPNOA2 cargada ok en el proyecto. Ahora debería funcionar la carga de ficheros Lidar.',
                duration=10,
                level=Qgis.Info,
            )
        else:
            print(f'betaraster-> No se pudo cargar la capa "cargar_nubeDePuntos_LidarPNOA2".')
            iface.messageBar().pushMessage(
                title='dasoraster',
                text='Parece que este PC tiene dificultades para leer la capa {cargar_nubeDePuntos_LidarPNOA2}. Comprueba que está en el proyecto.'\
                    '\nPuede seer debido a que no tiene acceso a la ubicación de red con la información de descarga de nubes de puntos. Es posible que no se esté ejecutando dentro de la JCyL o el usuario no esté dado de alta.',
                showMore=f'Si eres técnico de medio ambiente de la Junta de Castilla y León y estás trabajando con un PC dentro de la Junta y quieres tener acceso a este recurso\nEnvía un correo electrónico siguiendo las instrucciones que figuran en la guia de primeros pasos y en el manual de consulta.',
                duration=30,
                level=Qgis.Warning,
            )
            return False, None
    else:
        layer_selec = layer_selec[0]
    return True, layer_selec


def ajustar_escala_lasfile(punto_elegido):
    canvas = iface.mapCanvas()
    escala_actual = canvas.scale()
    print(f'betaraster-> La escala actual del canvas es: 1:{round(escala_actual)}')

    if escala_actual > 50000:
        iface.messageBar().pushMessage(
            title='dasoraster',
            text='Se amplia la escala para la carga de fichero Lidar de nubes de puntos (lasFiles).',
            # showMore=f'',
            duration=10,
            level=Qgis.Info,
        )
        canvas.setCenter(punto_elegido)
        escala_deseada = 20000
        # canvas.setScale(escala_deseada)
        # canvas.zoomToScale(escala_deseada)
        # Suponiendo que el tamaño del canvas es de 800x600 píxeles
        width = 300  # Ancho del canvas en píxeles
        height = 200  # Alto del canvas en píxeles
        # Calcular la extensión en unidades del sistema de referencia de coordenadas (CRS)
        # Esto puede variar dependiendo de tu CRS, aquí se asume que es en metros
        extent_deseado = QgsRectangle(
            punto_elegido.x() - (width / 2) * (escala_deseada / 1000),
            punto_elegido.y() - (height / 2) * (escala_deseada / 1000),
            punto_elegido.x() + (width / 2) * (escala_deseada / 1000),
            punto_elegido.y() + (height / 2) * (escala_deseada / 1000)
        )
        canvas.setExtent(extent_deseado)
        canvas.refresh()

def seleccionar_bloques(
        punto_elegido,
        layer_selecionado,
        desplazamiento_dcha_abajo=0,
        buffer_size=0.001,
    ):
    # Creo una geometría de punto (objeto de consulta)
    # punto_click_geometry = QgsGeometry.fromPointXY(punto_elegido)
    # request1 = QgsFeatureRequest().setFilterGeometry(transformed_point_geometry)  # Filtrar por geometría del punto
    # selected_features1 = layer_selecionado.getFeatures(request1)

    # Creo un objeto de consulta
    request = QgsFeatureRequest().setFilterRect(
        QgsRectangle(
            punto_elegido.x() + desplazamiento_dcha_abajo - buffer_size,
            punto_elegido.y() - desplazamiento_dcha_abajo - buffer_size,
            punto_elegido.x() + desplazamiento_dcha_abajo + buffer_size,
            punto_elegido.y() - desplazamiento_dcha_abajo + buffer_size
        )
    )
    selected_features = layer_selecionado.getFeatures(request)
    # print(f'betaraster-> selected_features de tipo: {type(selected_features)}. isValid: {selected_features.isValid()}')
    # print(dir(selected_features))
    # ['close', 'compileFailed', 'compileStatus', 'isClosed', 'isValid', 'nextFeature', 'rewind']

    # print(f'betaraster-> Número de features en el layer_selecionado: {layer_selecionado.featureCount()}')
    # print(f'betaraster-> Geometría del punto: {punto_click_geometry.asWkt()}')
    # feature_id = 21622
    # request_id = QgsFeatureRequest().setFilterFid(feature_id)
    # # Obtener la característica correspondiente
    # feature = layer_selecionado.getFeatures(request_id)
    # for f in feature:
    #     geometry = f.geometry()
    #     print(
    #         f'Geometría del polígono con ID {feature_id}: {geometry.asWkt()}')  # Imprime la geometría en formato WKT
    return selected_features

def cargar_nube_de_puntos(
        copc_1_value,
        copc_2_value,
        copc_any_value,
        cuadrante_1_value,
        cuadrante_2_value,
        copc_CE_value,
        copc_NE_value,
        copc_NW_value,
        copc_SE_value,
        copc_SW_value,
        # autocarga_mostrar_lasfiles_en_leyenda=True,
        verboseLocal=True,
):
    # Cargar la capa de nube de puntos
    # print(f'betaraster-> Ruta del lasFile 0: {copc_1_value}')
    # copc_1_value1 = f'\\\\{copc_1_value}'
    # print(f'betaraster-> Ruta del lasFile 1: {copc_1_value1}')
    # print(os.path.exists(copc_1_value1))
    # copc_1_value2 = r'\\' + copc_1_value
    # print(f'betaraster-> Ruta del lasFile 2: {copc_1_value2}')
    # print(os.path.exists(copc_1_value2))
    # copc_1_value3 = r'' + copc_1_value
    # print(f'betaraster-> Ruta del lasFile 3: {copc_1_value3}')
    # print(os.path.exists(copc_1_value3))
    # copc_1_value4 = r'{}'.format(copc_1_value)
    # print(f'betaraster-> Ruta del lasFile 4: {copc_1_value4}')
    # print(os.path.exists(copc_1_value4))
    # point_cloud_layer = QgsPointCloudLayer(copc_1_value4, 'Nube de Puntos', 'las')

    verboseBase = False
    verbosePlus = False
    verboseDebug = False
    verboseWarning = True

    copcLazFile_path_name_ok = copc_1_value

    carga_ok = 0

    if verboseLocal and verboseDebug:
        print(f'betaraster-> Cuadrante principal y secundario: {cuadrante_1_value} / {cuadrante_2_value}')
    if verboseLocal and verbosePlus:
        if cuadrante_1_value and cuadrante_2_value:
            iface.messageBar().pushMessage(
                f'Cuadrante principal y secundario: {cuadrante_1_value} / {cuadrante_2_value}',
                level=Qgis.Info,
                duration=5
            )
        elif cuadrante_1_value:
            iface.messageBar().pushMessage(
                f'Cuadrante principal: {cuadrante_1_value}',
                level=Qgis.Info,
                duration=5
            )
        else:
            pass
            # iface.messageBar().pushMessage(
            #     f'Bloque fuera de CyL; se intenta buscar fichero lidar...',
            #     level=Qgis.Info,
            #     duration=5
            #     )

    copcLazFile_path_name0 = ''
    copcLazFile_path_name1 = ''
    copcLazFile_path_name2 = ''
    copcLazFile_path_name_ok = ''
    if cuadrante_1_value.upper() == 'CE':
        copcLazFile_path_name_ok = copc_CE_value
    elif cuadrante_1_value.upper() == 'NE':
        copcLazFile_path_name_ok = copc_NE_value
    elif cuadrante_1_value.upper() == 'NW':
        copcLazFile_path_name_ok = copc_NW_value
    elif cuadrante_1_value.upper() == 'SE':
        copcLazFile_path_name_ok = copc_SE_value
    elif cuadrante_1_value.upper() == 'SW':
        copcLazFile_path_name_ok = copc_SW_value
    else:
        COPC_1 = f'COPC_{cuadrante_1_value.upper()}'
        COPC_2 = f'COPC_{cuadrante_2_value.upper()}'
        if cuadrante_1_value:
            copcLazFile_path_name_ok = COPC_1
        elif cuadrante_2_value:
            copcLazFile_path_name_ok = COPC_2
        else:
            copcLazFile_path_name1 = copc_1_value
            copcLazFile_path_name2 = copc_2_value
            copcLazFile_path_name0 = copc_any_value
            if not copcLazFile_path_name1 is None and copcLazFile_path_name1 and os.path.exists(
                    copcLazFile_path_name1):
                copcLazFile_path_name_ok = copcLazFile_path_name1
            elif not copcLazFile_path_name2 is None and copcLazFile_path_name2 and os.path.exists(
                    copcLazFile_path_name2):
                copcLazFile_path_name_ok = copcLazFile_path_name2
            elif not copcLazFile_path_name0 is None and copcLazFile_path_name0 and os.path.exists(
                    copcLazFile_path_name0):
                copcLazFile_path_name_ok = copcLazFile_path_name0
            else:
                copcLazFile_path_name_ok = None

    bloque_ya_descargado = False
    if copcLazFile_path_name_ok:
        if os.path.exists(copcLazFile_path_name_ok):
            mi_proyecto = QgsProject.instance()
            project_root = mi_proyecto.layerTreeRoot()
            grupo_lidar = project_root.findGroup(GRUPO_LIDAR_DESCARGADO)
            if grupo_lidar:
                # grupo_previo = True
                if verboseLocal and verbosePlus:
                    iface.messageBar().pushMessage(
                        f'Grupo TOC existe previamente: {str(grupo_lidar)}',
                        level=Qgis.Info,
                        duration=5
                    )
            else:
                # grupo_previo = False
                if verboseLocal and verbosePlus:
                    iface.messageBar().pushMessage(
                        f'Se crea el grupo {GRUPO_LIDAR_DESCARGADO} para contener las nubes de puntos.',
                        level=Qgis.Info,
                        duration=5
                    )
                # Con addGroup, el grupo se inserta al final de la lista de grupos
                # grupo_lidar = project_root.addGroup(GRUPO_LIDAR_DESCARGADO)
                #Con  insertGroup, el grupo se inserta en la posición indicada (la primera el 0), con la 1, debajo de la malla.
                grupo_lidar = project_root.insertGroup(0, GRUPO_LIDAR_DESCARGADO)  #

            lazFile_name = os.path.basename(copcLazFile_path_name_ok)
            for num, child in enumerate(project_root.children()):
                if isinstance(child, QgsLayerTreeGroup) and child.name() == GRUPO_LIDAR_DESCARGADO:
                    bloques_descargados = child.children()
                    for num_bl, bloque in enumerate(bloques_descargados):
                        if bloque.name() == lazFile_name:
                            bloque_ya_descargado = True
                            carga_ok = 2
                            if verboseLocal and verboseDebug:
                                print(f'betaraster-> -> {lazFile_name} ya descargado ({num_bl})')
                            if verboseLocal and verboseWarning:
                                iface.messageBar().pushMessage(
                                    f'Bloque Lidar ya descargado previamente: {lazFile_name}',
                                    level=Qgis.Info,
                                    duration=5
                                )
                            break

                if verboseLocal and verboseDebug:
                    print(f'betaraster-> {num}-> group: {child.name()}')
                    # print(f'betaraster-> Metodos del child de type group: {dir(child)}')
                    # ['NodeGroup', 'NodeLayer', 'NodeType', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattr__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'addChildNode', 'addGroup', 'addLayer', 'addedChildren', 'blockSignals', 'checkedLayers', 'childEvent', 'children', 'clone', 'connectNotify', 'convertToGroupLayer', 'customEvent', 'customProperties', 'customProperty', 'customPropertyChanged', 'deleteLater', 'depth', 'destroyed', 'disconnect', 'disconnectNotify', 'dump', 'dumpObjectInfo', 'dumpObjectTree', 'dynamicPropertyNames', 'event', 'eventFilter', 'expandedChanged', 'findChild', 'findChildren', 'findGroup', 'findGroups', 'findLayer', 'findLayerIds', 'findLayers', 'groupLayer', 'inherits', 'insertChildNode', 'insertChildNodes', 'insertChildrenPrivate', 'insertGroup', 'insertLayer', 'installEventFilter', 'isExpanded', 'isItemVisibilityCheckedRecursive', 'isItemVisibilityUncheckedRecursive', 'isMutuallyExclusive', 'isSignalConnected', 'isVisible', 'isWidgetType', 'isWindowType', 'itemVisibilityChecked', 'killTimer', 'metaObject', 'moveToThread', 'name', 'nameChanged', 'nodeType', 'nodeVisibilityChanged', 'objectName', 'objectNameChanged', 'parent', 'property', 'pyqtConfigure', 'readChildrenFromXml', 'readCommonXml', 'readXml', 'receivers', 'removeAllChildren', 'removeChildNode', 'removeChildren', 'removeChildrenGroupWithoutLayers', 'removeChildrenPrivate', 'removeCustomProperty', 'removeEventFilter', 'removeLayer', 'removedChildren', 'resolveReferences', 'sender', 'senderSignalIndex', 'setCustomProperty', 'setExpanded', 'setGroupLayer', 'setIsMutuallyExclusive', 'setItemVisibilityChecked', 'setItemVisibilityCheckedParentRecursive', 'setItemVisibilityCheckedRecursive', 'setName', 'setObjectName', 'setParent', 'setProperty', 'signalsBlocked', 'startTimer', 'staticMetaObject', 'takeChild', 'thread', 'timerEvent', 'tr', 'updateChildVisibilityMutuallyExclusive', 'visibilityChanged', 'willAddChildren', 'willRemoveChildren', 'writeCommonXml', 'writeXml']

            if verboseLocal and verboseDebug:
                print(f'betaraster-> project_root: {project_root}')
                print(f'betaraster-> children: {project_root.children()}')
                for num, child in enumerate(project_root.children()):
                    if isinstance(child, QgsLayerTreeGroup):
                        print(f'betaraster-> {num}-> group: {child.name()}')
                    elif isinstance(child, QgsLayerTreeLayer):
                        print(f'betaraster-> {num}-> layer: {child}-> ID: {child.layerId()}')
                        print(f'betaraster-> {num}-> layer: {child.name()}-> ID: {child.layerId()}')
                        # print(f'betaraster-> Metodos del child de type layer: {dir(child)}')
                        # ['AllowSplittingLegendNodesOverMultipleColumns', 'LegendNodesSplitBehavior', 'NodeGroup', 'NodeLayer', 'NodeType', 'PreventSplittingLegendNodesOverMultipleColumns', 'UseDefaultLegendSetting', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattr__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'addedChildren', 'attachToLayer', 'blockSignals', 'checkedLayers', 'childEvent', 'children', 'clone', 'connectNotify', 'customEvent', 'customProperties', 'customProperty', 'customPropertyChanged', 'deleteLater', 'depth', 'destroyed', 'disconnect', 'disconnectNotify', 'dump', 'dumpObjectInfo', 'dumpObjectTree', 'dynamicPropertyNames', 'event', 'eventFilter', 'expandedChanged', 'findChild', 'findChildren', 'inherits', 'insertChildrenPrivate', 'installEventFilter', 'isExpanded', 'isItemVisibilityCheckedRecursive', 'isItemVisibilityUncheckedRecursive', 'isSignalConnected', 'isVisible', 'isWidgetType', 'isWindowType', 'itemVisibilityChecked', 'killTimer', 'labelExpression', 'layer', 'layerId', 'layerLoaded', 'layerWillBeUnloaded', 'legendSplitBehavior', 'metaObject', 'moveToThread', 'name', 'nameChanged', 'nodeType', 'objectName', 'objectNameChanged', 'parent', 'patchShape', 'patchSize', 'property', 'pyqtConfigure', 'readCommonXml', 'readXml', 'receivers', 'removeChildrenPrivate', 'removeCustomProperty', 'removeEventFilter', 'removedChildren', 'resolveReferences', 'sender', 'senderSignalIndex', 'setCustomProperty', 'setExpanded', 'setItemVisibilityChecked', 'setItemVisibilityCheckedParentRecursive', 'setItemVisibilityCheckedRecursive', 'setLabelExpression', 'setLegendSplitBehavior', 'setName', 'setObjectName', 'setParent', 'setPatchShape', 'setPatchSize', 'setProperty', 'setUseLayerName', 'signalsBlocked', 'startTimer', 'staticMetaObject', 'takeChild', 'thread', 'timerEvent', 'tr', 'useLayerName', 'visibilityChanged', 'willAddChildren', 'willRemoveChildren', 'writeCommonXml', 'writeXml']

                # child0 = project_root.children()[0]
                # print(f'betaraster-> child0: {child0}' -> type: {type(child0)}')
                # print(f'betaraster-> child0 es un QgsLayerTreeLayer: {isinstance(child0, QgsLayerTreeLayer)}')
                ## print(f'betaraster-> parent: {child0.parent()}') #  qgis._core.QgsLayerTreeLayer
                # child0 = project_root.children()[1]
                # print(f'betaraster-> child1: {child1}' -> type: {type(child1)}')
                # print(f'betaraster-> child1 es un QgsLayerTreeLayer: {isinstance(child1, QgsLayerTreeLayer)}')

            if not bloque_ya_descargado:
                if verboseLocal and verboseBase:
                    iface.messageBar().pushMessage(
                        f'Cargando nube de puntos Lidar (copc.laz): {copcLazFile_path_name_ok}',
                        level=Qgis.Info,
                        duration=5
                    )
                # QgsMessageLog.logMessage(f'Se va a cargar {copcLazFile_path_name_ok}')
                pcl_LayerOptions = QgsPointCloudLayer.LayerOptions()
                pcl_LayerOptions.skipIndexGeneration = False
                pcl_LayerOptions.loadDefaultStyle = True
                pcl_ = 'copc'  # 'pdal' fuerza la generacion de otro copc
                my_pcl = QgsPointCloudLayer(copcLazFile_path_name_ok, lazFile_name, pcl_, pcl_LayerOptions)
                # my_QgsMapLayer = QgsProject.instance().addMapLayer(my_pcl)
                if my_pcl.isValid():
                    if grupo_lidar is not None:
                        QgsProject.instance().addMapLayer(my_pcl, False)
                        # Si el grupo existe, agregar la capa al grupo
                        grupo_lidar.addLayer(my_pcl)
                        # my_QgsMapLayer = grupo_lidar.addLayer(my_pcl)
                        # QgsProject.instance().addMapLayer(my_pcl, autocarga_mostrar_lasfiles_en_leyenda)
                        print(f'betaraster-> Se ha agregado la capa al grupo lidarDescargado')
                    else:
                        # Si el grupo no existe, agregar la capa directamente al proyecto
                        # QgsProject.instance().addMapLayer(my_pcl, autocarga_mostrar_lasfiles_en_leyenda)
                        QgsProject.instance().addMapLayer(my_pcl, True)
                        print(f'betaraster-> Se ha agregado la capa a la leyenda (sin grupo lidarDescargado)')
                    carga_ok = 1
                else:
                    print(f'betaraster-> No se ha posiso cargar el lazfile.')
                    carga_ok = 0
        else:
            carga_ok = -1
            if verboseLocal and verboseWarning:
                iface.messageBar().pushMessage(
                    f'Aviso: falta el bloque {copcLazFile_path_name_ok} (pendiente de copiar a \\repoarchivohm.jcyl.red). Notificar a {EMAIL_DASOLIDAR1}',
                    level=Qgis.Warning,
                    duration=15
                )
    else:
        if not copcLazFile_path_name1 is None and copcLazFile_path_name1:
            copcLazFile_path_name_fail = copcLazFile_path_name1
        elif not copcLazFile_path_name2 is None and copcLazFile_path_name2:
            copcLazFile_path_name_fail = copcLazFile_path_name1
        elif not copcLazFile_path_name0 is None and copcLazFile_path_name0:
            copcLazFile_path_name_fail = copcLazFile_path_name0
        else:
            copcLazFile_path_name_fail = None
        if verboseLocal and verboseWarning:
            if not copcLazFile_path_name_fail is None:
                # QMessageBox.warning(iface.mainWindow(), f'No se encuentra el fichero {copcLazFile_path_name_fail}')
                iface.messageBar().pushMessage(
                    f'Bloque {copcLazFile_path_name_fail} no disponible por lo que no se ha subido a \\repoarchivohm.jcyl.red',
                    level=Qgis.Warning,
                    duration=10
                )
            else:
                iface.messageBar().pushMessage(
                    f'No hay fichero disponible para este bloque 2x2 km (fuera de CyL)',
                    level=Qgis.Warning,
                    duration=10
                )
        carga_ok = -2
    try:
        mi_capa = QgsProject.instance().mapLayersByName('cargar_nubeDePuntos_LidarPNOA2')[0]
        iface.setActiveLayer(mi_capa)
    except:
        iface.messageBar().pushMessage(
            f'Aviso, se ha renombrado la capa cargar_nubeDePuntos_LidarPNOA2 -> Revisa código de esta acción para cambiarlo tb aqui.',
            level=Qgis.Warning,
            duration=10
        )
    # carga_ok-> 0: Algo falla; 1: Carga ok; 2: Ya cargado previamente; -1: No encontrado; -2: No hay bloque
    return (carga_ok, copcLazFile_path_name_ok)

def capa_vector_activa():
    # capa_activa_vector = False
    layer_rodales = None
    layer_activo = iface.activeLayer()  # Usar la capa activa si es vectorial
    if layer_activo is None:
        print(f'betaraster-> No hay ninguna capa activa.')
        mensaje(
            f'No hay ninguna capa activa. Activa una capa vectorial para poder hacer la consulta.',
            mi_level=Qgis.Warning)
    else:
        if layer_activo.type() == QgsMapLayer.RasterLayer:
            nombre_capa_activa = layer_activo.name()
            print(f'betaraster-> La capa activa es una capa raster (no ok): {nombre_capa_activa}')
            mensaje(f'La capa activa ({nombre_capa_activa}) es ráster. Activa una capa vectorial para poder hacer la consulta.', mi_level=Qgis.Warning)
        elif layer_activo.type() == QgsMapLayer.VectorLayer:
            nombre_capa_activa = layer_activo.name()
            print(f'betaraster-> La capa activa es una capa vectorial (ok): {nombre_capa_activa}.')
            if nombre_capa_activa == 'cargar_nubeDePuntos_LidarPNOA2':
                mensaje(f'Está seleccionada la malla de ficheros Lidar ({nombre_capa_activa}); elige una capa de rodales o similar.', mi_level=Qgis.Warning)
            else:
                mensaje(f'Se consulta el polígono en el que se ha hecho click en la capa activa: {nombre_capa_activa}.')
                # capa_activa_vector = True
                layer_rodales = layer_activo
        else:
            print(f'betaraster-> La capa activa no es ni raster ni vectorial.')
            mensaje(f'La capa activa no es vectorial. Activa una capa vectorial para poder hacer consultas.', mi_level = Qgis.Warning)
    layer_rodales = layer_activo
    return layer_rodales


class VentanaBienvenidaGuiaRapida(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.ok = True

        self.setWindowTitle('Productos y herramientas Lidar para la gestión del medio natural')
        # self.setFixedSize(500, 200)  #  Dimensiones XX, YY
        # self.setGeometry(100, 100, 700, 400)
        self.resize(950, 700)  # Ancho y alto en píxeles
        self.center()

        # ======================================================================
        print(f'betaraster-> Se va a mostrar la guia rápida')
        ruta_ayudas_red = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\doc\ayudaDasolidar'
        ruta_ayudas_local = os.path.join(PLUGIN_DIR, 'resources/docs')
        rutas_ayudas = [ruta_ayudas_red, ruta_ayudas_local]
        for ruta_ayudas in rutas_ayudas:
            intro_dasolidar_png_filepath = os.path.join(ruta_ayudas, 'GuiaDasoLidar.png')
            if os.path.exists(intro_dasolidar_png_filepath):
                if intro_dasolidar_png_filepath.startswith(r'\\'):
                    intro_dasolidar_html_filename = 'dasolidar_intro.html'
                else:
                    intro_dasolidar_html_filename = 'dasolidar_intro_local.html'
                intro_dasolidar_html_filepath = os.path.join(ruta_ayudas, intro_dasolidar_html_filename)
                if os.path.exists(intro_dasolidar_html_filepath):
                    break
        if not os.path.exists(intro_dasolidar_png_filepath) or not os.path.exists(intro_dasolidar_html_filepath):
            iface.messageBar().pushMessage(
                title='dasoraster',
                text='Guia rápida no disponible. Puede que no estés trabajando dentro de la intranet de la JCyL o no estés dado de alta en el proyecto dasolidar',
                duration=20,
                level=Qgis.Warning,
            )
            self.ok = False
            return

        intro_dasolidar_html_obj = open(intro_dasolidar_html_filepath)
        intro_dasolidar_html_read = intro_dasolidar_html_obj.read()
        print(f'betaraster-> Ruta de la guia rápida: {intro_dasolidar_html_filepath}')

        # Layout horizontal para el texto
        main_layout = QVBoxLayout()
        # usar_html = True
        self.mi_texto = QTextBrowser()
        self.mi_texto.setHtml(intro_dasolidar_html_read)
        # Ajusto el scroll para mostrar la parte superior
        self.mi_texto.verticalScrollBar().setValue(0)
        main_layout.addWidget(self.mi_texto)
        # intro_dasolidar_html_obj.close()

        self.ok_button = QPushButton('Ok')
        self.ok_button.clicked.connect(self.accept)
        main_layout.addWidget(self.ok_button)
        main_layout.setAlignment(self.ok_button, Qt.AlignCenter)

        # Establezco el layout principal
        self.setLayout(main_layout)

    def center(self):
        qr = self.frameGeometry()
        cp = self.screen().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())

def chekear_unidad_V(unidad_v_path, mensajes_path):
    if os.path.isdir(unidad_v_path):
        if os.path.isdir(mensajes_path):
            unidad_V_disponible = True
        else:
            try:
                os.mkdir(mensajes_path)
                unidad_V_disponible = True
            except FileExistsError:
                # Esto no debiera de pasar nunca, indica que algo falla al acceder a la ubicacion de red
                unidad_V_disponible = False
                print(f'betaraster-> El directorio "{mensajes_path}" ya existe.')
            except Exception as e:
                unidad_V_disponible = False
                print(f'betaraster-> Error al crear el directorio: {mensajes_path}')
                print(f'betaraster-> Error: {e}')
    else:
        unidad_V_disponible = False
    return unidad_V_disponible

def abrir_fichero_almacen(unidad_V_disponible, msg_filename):
    if unidad_V_disponible:
        try:
            msg_obj = open(msg_filename, mode='a+')
            msg_obj.seek(0)
            msg_previo = msg_obj.readlines()
        except Exception as e:
            print(f'betaraster-> Error al crear o abrir el fichero de mensajes: {msg_filename}')
            print(f'betaraster-> Error: {e}')
            msg_obj = None
            msg_previo = []
    else:
        msg_obj = None
        msg_previo = []
    return msg_obj


class VentanaDasonet(QDialog):
    def __init__(self, parent=None):
        print(f'betaraster-> Instanciando VentanaDasonet')
        super().__init__(parent)

        self.setWindowTitle('Edición o borrado de datos aportados a dasonet')
        # self.setFixedSize(500, 200)  #  Dimensiones XX, YY
        # self.setGeometry(100, 100, 700, 400)
        self.resize(450, 150)  #  Ancho y alto en píxeles
        self.center()

        # ======================================================================
        # Layout horizontal para el texto
        self.main_layout = QVBoxLayout()
        # Mensaje de texto
        self.mi_texto = QLabel('Indica qué datos quieres cambiar o borrar y, si lo deseas, el motivo:')
        self.mi_texto.setAlignment(Qt.AlignLeft)
        self.main_layout.addWidget(self.mi_texto)

        # # Ventana de texto con tamaño fijo
        # self.text_input = QLineEdit(self)
        self.text_input = QTextEdit(self)
        self.text_input.setFixedSize(400, 130)  # Establece el tamaño (ancho, alto) en píxeles
        self.main_layout.addWidget(self.text_input)

        # ======================================================================
        # botones_layout = QHBoxLayout()
        # # Añadir botones
        # # https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QPushButton.html
        # ======================================================================
        # Botones de Consulta, Acción y Cancelar
        self.buttonBox = QDialogButtonBox()
        self.buttonBox.setToolTip('dasonet (proyecto dasolidar)')
        # self.send_button = self.buttonBox.addButton('Enviar', QDialogButtonBox.AcceptRole)
        # ======================================================================

        self.edicion_borrado_dasonet_button = self.buttonBox.addButton('Enviar', QDialogButtonBox.AcceptRole)
        self.edicion_borrado_dasonet_button.setToolTip('Haz clic aquí para enviar tu petición de modificaicón o borrado al equipo dasolidar.')
        self.edicion_borrado_dasonet_button.clicked.connect(self.lanzar_edicion_borrado_dasonet)
        self.edicion_borrado_dasonet_button.setEnabled(True)

        self.cancel_button = self.buttonBox.addButton(QDialogButtonBox.Cancel)
        self.cancel_button.clicked.connect(self.reject)
        # ======================================================================

        # ======================================================================
        # Checkbox por si pido autorización para guardar la conaulta o petición en la base de datos
        self.dasonet_checkbox = QCheckBox(f'Eliminar de dasonet todos los datos aportados por mí ({usuario_actual}).')
        self.dasonet_checkbox.setChecked(False)
        self.main_layout.addWidget(self.dasonet_checkbox)
        # ======================================================================

        # Añadir el layout de botones al layout principal
        # self.main_layout.addLayout(botones_layout)
        self.main_layout.addWidget(self.buttonBox)

        # Establecer el layout principal
        self.setLayout(self.main_layout)

    def lanzar_edicion_borrado_dasonet(self):
        pass

    def enviar_dasonet(self):
        hoy_AAAAMMDD = datetime.fromtimestamp(time.time()).strftime('%Y%m%d')
        ahora_HHMMSS = datetime.fromtimestamp(time.time()).strftime('%H:%M:%S')
        dasonet_borrar_todo = self.dasonet_checkbox.isChecked()
        texto_codificado_consulta = f'COD332;{usuario_actual};{hoy_AAAAMMDD};{ahora_HHMMSS}\n'
        texto_codificado_consulta += f'dasonet;Borrar todo:;{dasonet_borrar_todo}\n'
        texto_codificado_consulta += f'{self.text_input.toPlainText()}\n'
        enviar_mail_datos_parcela_rodal_consulta(
            cuerpo=texto_codificado_consulta,
            motivo='dasonet',
            # borrar_todo=dasonet_borrar_todo,
        )

    def lanzar_edicion_borrado_dasonet(self):
        print(f'betaraster-> lanzar_edicion_borrado_dasonet')
        self.button_pressed = f'Enviar_edicion_borrado_dasonet'
        self.accept()
        print(f'betaraster-> Botón presionado: {self.button_pressed}. Texto introducido: {self.text_input.toPlainText()}')
        self.enviar_dasonet()

    def center(self):
        qr = self.frameGeometry()
        cp = self.screen().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())

    def get_text(self):
        return self.text_input.toPlainText()


# Copiar en el script de arranque
# ==============================================================================
class VentanaAsistente(QDialog):
    def __init__(self, parent=None, botones_disponibles='sugerencia_consulta_bengi'):
        print(f'betaraster-> Instanciando VentanaAsistente con botones_disponibles = {botones_disponibles}')
        super().__init__(parent)

        # NO-> botones_disponibles='consulta_bengi'
        # botones_disponibles='sugerencia_consulta_bengi'
        # botones_disponibles='sugerencia_consulta_bengi_vega'
        # botones_disponibles='sugerencia_consultas_ejecucion'

        print(f'betaraster-> botones_disponibles: {botones_disponibles}')
        if botones_disponibles == 'sugerencia_consulta_bengi':
            self.setWindowTitle('Aquí puedes escribir sugerencias y consultas.')
        elif botones_disponibles == 'sugerencia_consultas_ejecucion':
            self.setWindowTitle('Aquí puedes hacer sugerencias, consultas o peticiones. Próximamente podrás pedir que se ejecute una acción.')
        else:
            self.setWindowTitle('Disponible próximamente.')
        # self.setFixedSize(500, 200)  #  Dimensiones XX, YY
        # self.setGeometry(100, 100, 700, 400)
        self.resize(600, 200)  #  Ancho y alto en píxeles
        self.center()

        # ======================================================================
        # Layout horizontal para el texto
        self.main_layout = QVBoxLayout()
        # Mensaje de texto
        self.mi_texto = QLabel('Escribe tu consulta o petición:')
        self.mi_texto.setAlignment(Qt.AlignLeft)
        self.main_layout.addWidget(self.mi_texto)

        # # Ventana de texto con tamaño fijo
        # self.text_input = QLineEdit(self)
        self.text_input = QTextEdit(self)
        self.text_input.setFixedSize(550, 100)  # Establece el tamaño (ancho, alto) en píxeles
        self.main_layout.addWidget(self.text_input)

        # ======================================================================
        # botones_layout = QHBoxLayout()
        # # Añadir botones
        # # https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QPushButton.html
        # ======================================================================
        # Botones de Consulta, Acción y Cancelar
        self.buttonBox = QDialogButtonBox()
        self.buttonBox.setToolTip('dasoraster (proyecto dasolidar)')
        # self.send_button = self.buttonBox.addButton('Enviar', QDialogButtonBox.AcceptRole)
        # ======================================================================

        # ======================================================================
        if botones_disponibles == 'consulta_bengi':
            self.consulta_bengi_button = self.buttonBox.addButton('Enviar consulta', QDialogButtonBox.AcceptRole)
            self.consulta_bengi_button.setToolTip('Haz clic aquí para enviar una consulta al equipo dasolidar.')
            self.consulta_bengi_button.clicked.connect(
                lambda event: self.lanzar_sugerencia_consulta_accion(
                    mi_evento=event,
                    tipo_consulta='bengi',
                )
            )
            self.consulta_bengi_button.setEnabled(True)
        elif botones_disponibles.startswith('sugerencia_consulta_bengi'):
            self.sugerencia_button = self.buttonBox.addButton('Enviar sugerencia', QDialogButtonBox.AcceptRole)
            self.sugerencia_button.setToolTip('Haz clic aquí para enviar una sugerencia o petición al equipo dasolidar.')
            self.sugerencia_button.clicked.connect(
                lambda event: self.lanzar_sugerencia_consulta_accion(
                    mi_evento=event,
                    tipo_consulta='sugerencia',
                )
            )
            self.sugerencia_button.setEnabled(True)
            if botones_disponibles =='sugerencia_consulta_bengi':
                self.consulta_bengi_button = self.buttonBox.addButton('Enviar consulta', QDialogButtonBox.AcceptRole)
                self.consulta_bengi_button.setToolTip('Haz clic aquí para enviar una consulta al equipo dasolidar.')
                self.consulta_bengi_button.clicked.connect(
                    lambda event: self.lanzar_sugerencia_consulta_accion(
                        mi_evento=event,
                        tipo_consulta='bengi',
                    )
                )
            elif botones_disponibles == 'sugerencia_consulta_bengi_vega':
                self.consulta_bengi_button = self.buttonBox.addButton('Consultar a humanos', QDialogButtonBox.AcceptRole)
                self.consulta_bengi_button.setToolTip('Haz clic aquí para enviar una consulta al equipo dasolidar.')
                self.consulta_vega_button = self.buttonBox.addButton('Consultar a Vega', QDialogButtonBox.AcceptRole)
                if usuario_alfa:
                    self.consulta_vega_button.setToolTip('Haz clic aquí para enviar una consulta a Vega (IA).')
                else:
                    self.consulta_vega_button.setToolTip('Opción solo disponible para alfa testers.')
                self.consulta_bengi_button.clicked.connect(
                    lambda event: self.lanzar_sugerencia_consulta_accion(
                        mi_evento=event,
                        tipo_consulta='bengi',
                    )
                )
                self.consulta_bengi_button.setEnabled(True)
                self.consulta_vega_button.clicked.connect(
                    lambda event: self.lanzar_sugerencia_consulta_accion(
                        mi_evento=event,
                        tipo_consulta='vega',
                    )
                )
                if usuario_alfa:
                    self.consulta_vega_button.setEnabled(True)
                else:
                    self.consulta_vega_button.setEnabled(False)
            self.consulta_bengi_button.setEnabled(True)

            self.dasonet_button = self.buttonBox.addButton('Dasonet', QDialogButtonBox.AcceptRole)
            self.dasonet_button.setToolTip('Haz clic aquí para retirar o modificar datos (parcelas o rodales) aportados a dasonet.')
            self.dasonet_button.clicked.connect(self.editar_dasonet)
            # self.dasonet_button.clicked.connect(
            #     lambda event: self.editar_dasonet(
            #         mi_evento=event,
            #     )
            # )
            self.dasonet_button.setEnabled(True)


        elif botones_disponibles == 'sugerencia_consultas_ejecucion':
            self.sugerencia_button = self.buttonBox.addButton('Enviar sugerencia', QDialogButtonBox.AcceptRole)
            self.sugerencia_button.setToolTip('Haz clic aquí para enviar una sugerencia o petición al equipo dasolidar.')
            self.consulta_bengi_button = self.buttonBox.addButton('Consultar a humanos', QDialogButtonBox.AcceptRole)
            self.consulta_bengi_button.setToolTip('Haz clic aquí para enviar una consulta al equipo dasolidar.')
            self.consulta_vega_button = self.buttonBox.addButton('Consultar a Vega', QDialogButtonBox.AcceptRole)
            if usuario_alfa:
                self.consulta_vega_button.setToolTip('Haz clic aquí para enviar una consulta a Vega (IA).')
            else:
                self.consulta_vega_button.setToolTip('Opción solo disponible para alfa testers.')

            self.dasonet_button = self.buttonBox.addButton('Dasonet', QDialogButtonBox.AcceptRole)
            self.dasonet_button.setToolTip('Haz clic aquí para retirar o modificar datos (parcelas o rodales) aportados a dasonet.')

            self.accion_button = self.buttonBox.addButton('Ejecutar acción', QDialogButtonBox.AcceptRole)
            if usuario_alfa:
                self.accion_button.setToolTip('Haz clic aquí para pedir a Vega que ejecute una acción. Pidelo con lenguaje natural, como lo harías a tu compañero de trabajo.')
            else:
                self.consulta_vega_button.setToolTip('Opción solo disponible para alfa testers.')

            self.sugerencia_button.clicked.connect(
                lambda event: self.lanzar_sugerencia_consulta_accion(
                    mi_evento=event,
                    tipo_consulta='sugerencia',
                )
            )
            self.consulta_bengi_button.clicked.connect(
                lambda event: self.lanzar_sugerencia_consulta_accion(
                    mi_evento=event,
                    tipo_consulta='bengi',
                )
            )
            self.consulta_vega_button.clicked.connect(
                lambda event: self.lanzar_sugerencia_consulta_accion(
                    mi_evento=event,
                    tipo_consulta='vega',
                )
            )
            self.accion_button.clicked.connect(
                # self.lanzar_accion
                lambda event: self.lanzar_sugerencia_consulta_accion(
                    mi_evento=event,
                    tipo_consulta='accion',
                )
            )
            self.dasonet_button.clicked.connect(self.editar_dasonet)
            # self.dasonet_button.clicked.connect(
            #     lambda event: self.editar_dasonet(
            #         mi_evento=event,
            #     )
            # )

            self.sugerencia_button.setEnabled(True)
            self.consulta_bengi_button.setEnabled(True)
            self.dasonet_button.setEnabled(True)
            if usuario_alfa:
                self.consulta_vega_button.setEnabled(True)
                self.accion_button.setEnabled(True)
            else:
                self.consulta_vega_button.setEnabled(False)
                self.accion_button.setEnabled(False)

        else:
            self.consulta_bengi_button = self.buttonBox.addButton('Enviar consulta', QDialogButtonBox.AcceptRole)
            self.consulta_bengi_button.clicked.connect(
                lambda event: self.lanzar_sugerencia_consulta_accion(
                    mi_evento=event,
                    tipo_consulta='bengi',
                )
            )
            self.consulta_bengi_button.setEnabled(True)
        self.cancel_button = self.buttonBox.addButton(QDialogButtonBox.Cancel)
        self.cancel_button.clicked.connect(self.reject)
        # ======================================================================

        # ======================================================================
        # Checkbox por si pido autorización para guardar la conaulta o petición en la base de datos
        self.guardar_consulta_checkbox = QCheckBox('Guardar sugerencia, petición, consulta o ejecución en fichero de texto para que esté a disposición de todos los usuarios.')
        self.guardar_consulta_checkbox.setChecked(True)
        self.main_layout.addWidget(self.guardar_consulta_checkbox)
        # ======================================================================

        # Añadir el layout de botones al layout principal
        # self.main_layout.addLayout(botones_layout)
        self.main_layout.addWidget(self.buttonBox)

        # Establecer el layout principal
        self.setLayout(self.main_layout)

    def center(self):
        qr = self.frameGeometry()
        cp = self.screen().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())

    def get_text(self):
        return self.text_input.toPlainText()

    def guardar_consulta(
            self,
            tipo_consulta,
        ):
        if tipo_consulta == 'bengi' or tipo_consulta == 'vega':
            clase_consulta = 'consulta'
        elif tipo_consulta == 'accion':
            clase_consulta = tipo_consulta
        else:
            clase_consulta = tipo_consulta

        hoy_AAAAMMDD = datetime.fromtimestamp(time.time()).strftime('%Y%m%d')
        ahora_HHMMSS = datetime.fromtimestamp(time.time()).strftime('%H:%M:%S')
        unidad_v_path = 'V:/MA_SCAYLE_VueloLidar'
        mensajes_path = os.path.join(unidad_v_path, 'dasoraster')
        unidad_V_disponible = chekear_unidad_V(unidad_v_path, mensajes_path)
        msg_filename = os.path.join(mensajes_path, f'{clase_consulta}s.dsl')
        msg_obj = abrir_fichero_almacen(unidad_V_disponible, msg_filename)
        msg_guardado_ok = False
        if msg_obj:
            texto_codificado_consulta = f'COD332;{usuario_actual};{hoy_AAAAMMDD};{ahora_HHMMSS};{self.text_input.toPlainText()}\n'
            try:
                msg_obj.write(texto_codificado_consulta)
                msg_obj.close()
                msg_guardado_ok = True
                if (tipo_consulta == 'sugerencia' or tipo_consulta == 'bengi') and False:
                    QMessageBox.information(
                        iface.mainWindow(),
                        f'{clase_consulta} dasolidar',
                        f'Muchas gracias por tu {clase_consulta}.'
                        f'\nIntentaremos responder lo antes posible.'
                        f'\nLo haremos preferentemente por correo electrónico.'
                        f'\nTu e-mail: {usuario_actual}@jcyl.es'
                    )
            except Exception as e:
                print(f'betaraster-> Error al guardar el mensaje en {msg_filename}')
                print(f'betaraster-> Error: {e}')
        print(f'betaraster-> msg_guardado_ok: {msg_guardado_ok}')
        if tipo_consulta == 'sugerencia' or tipo_consulta == 'bengi':
            if not msg_guardado_ok:
                QMessageBox.information(
                    iface.mainWindow(),
                    f'{clase_consulta} dasolidar',
                    f'No ha sido posible registrar tu {clase_consulta}.'
                    f'\nEsta utilidad solo funciona dentro de la intranet de la JCyL.'
                    f'\nSi quieres hacer una {clase_consulta} puedes enviar'
                    f'\nun correo electrónico a {EMAIL_DASOLIDAR1}'
                )

    def enviar_consulta(
            self,
            tipo_consulta,
        ):
        hoy_AAAAMMDD = datetime.fromtimestamp(time.time()).strftime('%Y%m%d')
        ahora_HHMMSS = datetime.fromtimestamp(time.time()).strftime('%H:%M:%S')
        if tipo_consulta == 'dasonet':
            texto_codificado_consulta = f'COD332;{usuario_actual};{hoy_AAAAMMDD};{ahora_HHMMSS}\n'
            texto_codificado_consulta += f'dasonet;Borrar todo:;{False}\n'
            texto_codificado_consulta += f'{self.text_input.toPlainText()}\n'
        else:
            texto_codificado_consulta = f'COD332;{usuario_actual};{hoy_AAAAMMDD};{ahora_HHMMSS}\n{self.text_input.toPlainText()}\n'

        enviar_mail_datos_parcela_rodal_consulta(
            cuerpo=texto_codificado_consulta,
            motivo=tipo_consulta,
        )

    def lanzar_sugerencia_consulta_accion(
            self,
            mi_evento=None,
            mi_boton=None,
            tipo_consulta='bengi'
        ):
        if tipo_consulta == 'bengi' or tipo_consulta == 'vega':
            clase_consulta = 'consulta'
        else:
            clase_consulta = tipo_consulta
        print(f'betaraster-> lanzar_sugerencia_consulta_accion -> tipo_consulta {tipo_consulta}')
        self.button_pressed = f'consulta_{tipo_consulta}'
        self.accept()
        print(f'betaraster-> Botón presionado: {self.button_pressed}. Texto introducido: {self.text_input.toPlainText()}')
        print(f'betaraster-> guardar_consulta_checkbox: {self.guardar_consulta_checkbox.isChecked()}')
        if tipo_consulta == 'sugerencia' or tipo_consulta == 'bengi' or tipo_consulta == 'vega':
            guardar_consultas_en_txt = True
            enviar_consultas_por_mail = True
            if self.guardar_consulta_checkbox.isChecked() and guardar_consultas_en_txt:
                self.guardar_consulta(tipo_consulta)
            if enviar_consultas_por_mail and tipo_consulta != 'accion':
                self.enviar_consulta(tipo_consulta)
        if tipo_consulta == 'vega':
            QMessageBox.information(
                iface.mainWindow(),
                f'Consulta dasolidar <{clase_consulta}>',
                f'Esta utilidad estará disponible próximamente\n\nGracias por la consulta.'
            )
        if tipo_consulta == 'accion':
            QMessageBox.information(
                iface.mainWindow(),
                f'Acción dasolidar <{clase_consulta}>',
                f'Esta utilidad estará disponible próximamente.'
            )
        # return (self.text_input.toPlainText(), 'consulta')

    # def lanzar_accion(self):
    #     print(f'betaraster-> lanzar_accion')
    #     self.button_pressed = 'accion'
    #     self.accept()
    #     print(self.text_input.toPlainText(), 'accion')
    #     QMessageBox.information(
    #         iface.mainWindow(),
    #         'Petición dasolidar',
    #         f'Gracias por la petición.\nEsta utilidad estará disponible próximamente'
    #     )
    #     # return (self.text_input.toPlainText(), 'accion')

    def editar_dasonet(self):
        print(f'betaraster-> Se va editar / modificar los datos aportados a dasonet')
        self.button_pressed = f'Enviar_edicion_borrado_dasonet'
        if self.text_input.toPlainText() != '':
            self.accept()
            self.enviar_consulta('dasonet')
        else:
            self.accept()
            QMessageBox.information(
                iface.mainWindow(),
                f'Editar/borrar aportaciones a dasonet',
                f'Por el momento solo se pueden editar o borrar aportaciones de forma manual.\n'\
                f'Escribe en la siguiente ventana algún dato de tu aportación para que\n'\
                f'la localicemos y, si quieres, también el motivo del cambio/borrado.\n'\
                f'Nosotros nos encargamos de buscarla y editarla o borrarla siguiendo tus instrucciones.'
            )
            print(f'betaraster-> Mensaje mostrados')
            try:
                dialog = VentanaDasonet(parent=None)
                rpta_ok = dialog.exec_()
                print(f'betaraster-> Rpta de VentanaDasonet: {rpta_ok}')
            except Exception as e:
                print(f'betaraster-> Ocurrió un error al mostrar la ventana dasonet 1: {e}')
            # Esto siguiente sobra; lo dejo just in case
            if rpta_ok == QDialog.Accepted:
                consulta_usuario = dialog.get_text()
                boton_pulsado = dialog.button_pressed
                print(f'betaraster-> Texto de consulta o petición:', consulta_usuario)
                print(f'betaraster-> Botón pulsado:', boton_pulsado)
            else:
                print(f'betaraster-> Consulta o petición canceladas')



# ==============================================================================
class AutoCargaLasFile(QgsMapToolEmitPoint):
    def __init__(
            self,
            canvas,
            autocarga_escala_maxima=AUTOCARGA_ESCALA_MAXIMA_RECOMENDADA,
            # autocarga_mostrar_lasfiles_en_leyenda=True,
            verboseLocal=False,
    ):
        super(AutoCargaLasFile, self).__init__(canvas)
        print(f'betaraster-> Iniciando AutoCargaLasFile')

        self.canvas = canvas
        self.autocarga_escala_maxima = autocarga_escala_maxima
        # self.autocarga_mostrar_lasfiles_en_leyenda = autocarga_mostrar_lasfiles_en_leyenda
        self.previous_extent = self.canvas.extent()
        self.iface = iface
        self.verboseLocal = verboseLocal
        # self.mapCanvas = iface.mapCanvas()
        self.active_auto_lasfile = True
        self.lista_lasfiles_cargados = []

        # Conectar señales
        # mapCanvasRefreshed se lanza con cualquier cambio de canvas
        # pero va después de scaleChanged y el trabajo lo hace siempre on_canvas_changed
        self.canvas.mapCanvasRefreshed.connect(self.on_canvas_changed)
        # scaleChanged se lanza antes de mapCanvasRefreshed y con cualquier cambio de canvas aunque no cambie la escala
        self.canvas.scaleChanged.connect(self.on_scale_changed)
        # Solo uno de los dos lanza on_extent_changed<> porque la primera ya actualiza el extent
        # Y la segunda simplemente verifica que el nuevo extent se mantiene

        # self.setCursor(QgsApplication.getThemeCursor(QgsApplication.Cursor.CrossHair))

        # Obtener la capa de nube de puntos
        self.malla_disponible, self.layer_selec = capa_malla_lasfiles()
        if not self.malla_disponible or self.layer_selec is None:
            iface.messageBar().pushMessage(
                title='dasoraster',
                text=f'La descarga automática de ficheros Lidar no está disponible en este proyecto o ubicación',
                # showMore=f'',
                duration=15,
                level=Qgis.Warning,
            )
            return

        # Carga los lasfiles del canvas actual
        self.actualizar_lasfiles()
        self.active_extra = False

    def on_canvas_changed(self):
        print(f'betaraster-> \ndasoraster-> on_canvas_changed-> self.active_auto_lasfile: {self.active_auto_lasfile}')
        current_extent = self.canvas.extent()
        print(f'betaraster-> \tprevious_extent: {self.previous_extent}')
        print(f'betaraster-> \tcurrent_extent:  {current_extent}')
        if current_extent != self.previous_extent:
            self.on_extent_changed()
            self.previous_extent = current_extent
        # self.actualizar_lasfiles()

    def on_scale_changed(self):
        print(f'betaraster-> \ndasoraster-> on_scale_changed-> self.active_auto_lasfile: {self.active_auto_lasfile}')
        current_extent = self.canvas.extent()
        print(f'betaraster-> \tprevious_extent: {self.previous_extent}')
        print(f'betaraster-> \tcurrent_extent:  {current_extent}')
        if current_extent != self.previous_extent:
            self.on_extent_changed()
            self.previous_extent = current_extent
        # self.actualizar_lasfiles()

    def on_extent_changed(self):
        self.actualizar_lasfiles()

    def actualizar_lasfiles(self):
        print(f'betaraster-> actualizar_lasfiles-> self.active_auto_lasfile: {self.active_auto_lasfile}')
        # (extent_actual, top_left, bottom_right) = self.esquinas_extent()
        if self.active_auto_lasfile:
            escala_actual = self.canvas.scale()
            # print(f'betaraster-> Escala actual: 1:{round(escala_actual)} (herramienta activa: {escala_actual <= self.autocarga_escala_maxima})')
            if escala_actual > self.autocarga_escala_maxima:
                iface.messageBar().pushMessage(
                    title='dasoraster',
                    text=f'La carga automatica no se activa para escalas inferiores a 1:{self.autocarga_escala_maxima} (el denominador debe ser > {self.autocarga_escala_maxima}). Se puede modificar en Settings.',
                    # showMore=f'',
                    duration=10,
                    level=Qgis.Warning,
                )
                return
            (extent_actual, x_ini, x_fin, y_ini, y_fin) = self.esquinas_bloques(DIMENSION_BLOQUE, verbose=False)
            self.lista_lasfiles_cargando = []
            contador_bloques_totales = 0
            contador_bloques_cargados = 0
            for x_bloque in range (x_ini, x_fin + DIMENSION_BLOQUE, DIMENSION_BLOQUE):
                for y_bloque in range(y_ini, y_fin + DIMENSION_BLOQUE, DIMENSION_BLOQUE):
                    esquina_sup_izda_bloque = QgsPointXY(x_bloque, y_bloque)
                    selected_features = seleccionar_bloques(
                        esquina_sup_izda_bloque,
                        self.layer_selec,
                        desplazamiento_dcha_abajo=1,
                    )
                    if selected_features:
                        # Convierto el iterador a una lista para contar las características
                        features_list = list(selected_features)
                        num_features = len(features_list)
                        if num_features != 1:
                            print(f'betaraster-> Número de bloques seleccionados-> {num_features} (debería ser uno solo)')
                        for feature in features_list:
                            contador_bloques_totales += 1
                            # Obtener el valor del campo COPC1
                            copc_1_value = feature['COPC1']
                            copc_2_value = feature['COPC2']
                            copc_any_value = feature['COPC_ANY']
                            cuadrante_1_value = feature['Cuadrante']
                            cuadrante_2_value = feature['Cuadrante2']
                            copc_CE_value = feature['COPC_CE']
                            copc_NE_value = feature['COPC_NE']
                            copc_NW_value = feature['COPC_NW']
                            copc_SE_value = feature['COPC_SE']
                            copc_SW_value = feature['COPC_SW']
                            # print(f'betaraster-> Bloque ID: {feature.id()}, COPC1: {type(copc_1_value)}: {copc_1_value}')
                            if type(copc_1_value) == str and not 'Aviso' in copc_1_value:
                                # carga_ok-> 0: Algo falla; 1: Carga ok; 2: Ya cargado previamente; -1: No encontrado; -2: No hay bloque
                                (carga_ok, copcLazFile_path_name_ok) = cargar_nube_de_puntos(
                                    copc_1_value,
                                    copc_2_value,
                                    copc_any_value,
                                    cuadrante_1_value,
                                    cuadrante_2_value,
                                    copc_CE_value,
                                    copc_NE_value,
                                    copc_NW_value,
                                    copc_SE_value,
                                    copc_SW_value,
                                    # autocarga_mostrar_lasfiles_en_leyenda=self.autocarga_mostrar_lasfiles_en_leyenda,
                                    verboseLocal=self.verboseLocal,
                                )
                                if carga_ok > 0:
                                    if not copcLazFile_path_name_ok in self.lista_lasfiles_cargando:
                                        self.lista_lasfiles_cargando.append(copcLazFile_path_name_ok)
                                    if not copcLazFile_path_name_ok in self.lista_lasfiles_cargados:
                                        self.lista_lasfiles_cargados.append(copcLazFile_path_name_ok)
                                    contador_bloques_cargados += 1
                                # copcLazFile_name_ok = os.path.splitext(os.path.basename(copcLazFile_path_name_ok))[0]
                                copcLazFile_name_ok = os.path.basename(copcLazFile_path_name_ok)
                                print(f'betaraster-> \t-> Fichero lidar: {copcLazFile_name_ok}; carga_ok: {carga_ok}')
                            else:
                                print(
                                    f'\t-> Fichero no válido o no disponible: {copc_1_value}'
                                )
            # print(f'betaraster-> contador_bloques_totales:    {contador_bloques_totales}')
            print(f'betaraster-> contador_bloques_cargados:    {contador_bloques_cargados} = {len(self.lista_lasfiles_cargando)}')
            print(f'betaraster-> num bloques previos+cargados: {len(self.lista_lasfiles_cargados)}')

            mi_proyecto = QgsProject.instance()
            project_root = mi_proyecto.layerTreeRoot()
            grupo_lidar = project_root.findGroup(GRUPO_LIDAR_DESCARGADO)
            if not grupo_lidar:
                print(f'betaraster-> No hay grupo {GRUPO_LIDAR_DESCARGADO} -> Se crea para contener los lasfiles')
                # grupo_previo = False
                if self.verboseLocal:
                    iface.messageBar().pushMessage(
                        f'Se crea el grupo {GRUPO_LIDAR_DESCARGADO} para contener las nubes de puntos.',
                        level=Qgis.Info,
                        duration=5
                    )
                # grupo_lidar = project_root.addGroup(GRUPO_LIDAR_DESCARGADO)
                grupo_lidar = project_root.insertGroup(1, GRUPO_LIDAR_DESCARGADO)
            if grupo_lidar:
                for layer in grupo_lidar.children():
                    if layer.layer() is not None:
                        layer_path = layer.layer().dataProvider().dataSourceUri()
                        if layer_path not in self.lista_lasfiles_cargando:
                            # Eliminar la capa del proyecto por no estar visible
                            print(f'betaraster-> Se elimina del proyecto la capa {layer.layer().name()}')
                            print(f'betaraster-> \tLayer.id: {layer.layer().id()}')
                            if layer_path in self.lista_lasfiles_cargados:
                                self.lista_lasfiles_cargados.remove(layer_path)
                                print(f'betaraster-> \t-> Eliminada tb de la lista self.lista_lasfiles_cargados.')
                            else:
                                print(f'betaraster-> \t-> No estába en la lista self.lista_lasfiles_cargados ¿?.')
                            mi_proyecto.removeMapLayer(layer.layer().id())
                        else:
                            print(f'betaraster-> Se mantiene la capa {layer.layer().name()}')
                    else:
                        print(f'betaraster-> Algo falla porque la capa es None {layer.layer()}')


    def esquinas_extent(self, verbose=False):
        # Obtener las esquinas del canvas
        extent_actual = self.canvas.extent()
        top_left = QgsPointXY(extent_actual.xMinimum(), extent_actual.yMaximum())
        bottom_right = QgsPointXY(extent_actual.xMaximum(), extent_actual.yMinimum())
        if verbose:
            print(f'betaraster-> \tEsquina sup izda: {top_left}')
            print(f'betaraster-> \tEsquina inf dcha: {bottom_right}')
        return (extent_actual, top_left, bottom_right)

    def esquinas_bloques(self, DIMENSION_BLOQUE, verbose=False):
        extent_actual = self.canvas.extent()
        x_ini = DIMENSION_BLOQUE * math.floor(extent_actual.xMinimum() / DIMENSION_BLOQUE)
        x_fin = DIMENSION_BLOQUE * math.floor(extent_actual.xMaximum() / DIMENSION_BLOQUE)
        y_ini = DIMENSION_BLOQUE * math.ceil(extent_actual.yMinimum() / DIMENSION_BLOQUE)
        y_fin = DIMENSION_BLOQUE * math.ceil(extent_actual.yMaximum() / DIMENSION_BLOQUE)
        if verbose:
            print(f'betaraster-> esquinas_bloques:')
            print(f'betaraster-> \t-> Min X Y: {x_ini} {y_ini}')
            print(f'betaraster-> \t-> Max X Y: {x_fin} {y_fin}')
        return (extent_actual, x_ini, x_fin, y_ini, y_fin)

    def check_scale(self):
        scale = self.canvas.scale()
        if scale < 10000:
            QMessageBox.warning(self.iface.mainWindow(), 'Advertencia', f'La escala ({scale}) es inferior a 1:10000.')

    def unload(self):
        # Desconectar señales al desactivar el complemento
        self.canvas.mapCanvasRefreshed.disconnect(self.on_canvas_changed)
        self.canvas.scaleChanged.disconnect(self.on_scale_changed)
        self.iface.removeToolBarIcon(self.action)


class ConsultarRodalTool(QgsMapToolEmitPoint):
    def __init__(self, canvas):
        super().__init__(canvas)
        self.canvas = canvas
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)  # Definir rubberBand
        self.rubberBand.setColor(Qt.red)  # Color del rubberBand
        self.rubberBand.setWidth(2)  # Ancho del rubberBand
        print(f'betaraster-> Instanciando ConsultarRodalTool')
        self.setCursor()


class PDFViewer(QMainWindow):
    def __init__(self, pdf_path):
        from PyQt5.QtWebEngineWidgets import QWebEngineView
        super().__init__()
        self.setWindowTitle('PDF Viewer')
        self.setGeometry(100, 100, 800, 600)

        self.browser = QWebEngineView()
        self.browser.setUrl(QUrl.fromLocalFile(pdf_path))

        self.setCentralWidget(self.browser)


def pedir_datos_parcela_rodal(
        tipo_consulta,
        cod_variable_explicada,
        cod_num_asimilada_sp_,
    ):

    if cod_num_asimilada_sp_ and cod_num_asimilada_sp_ in dict_spp_mfe25cyl.keys():
        cod_2L_especie = dict_spp_mfe25cyl[cod_num_asimilada_sp_][0]
    else:
        cod_2L_especie = 'Xx'

    # print(f'betaraster-> cod_num_asimilada_sp_: {cod_num_asimilada_sp_}')
    # print(f'betaraster-> cod_2L_especie: {cod_2L_especie}')

    num_especie_preseleccionada = 0
    lista_especie_nombre_2L = []
    for contador_especie, (key, value) in enumerate(dict_especies.items()):
        lista_especie_nombre_2L.append(f'{value} ({key})')
        # print(f'betaraster-> {cod_2L_especie} -> {key}')
        if cod_2L_especie == key:
            # print(f'    betaraster-> ok')
            num_especie_preseleccionada = contador_especie

    # print(f'betaraster-> num_especie_preseleccionada: {num_especie_preseleccionada}')
    # print(f'betaraster-> cod_variable_explicada: {cod_variable_explicada}')
    # print(f'betaraster-> dict_cod_variables_dasometricas.keys(): {dict_cod_variables_dasometricas.keys()}')
    if cod_variable_explicada in dict_cod_variables_dasometricas.keys():
        nombre_variable_explicada = dict_cod_variables_dasometricas[cod_variable_explicada][0]
    elif cod_variable_explicada == 'Xx':
        nombre_variable_explicada = 'Desconocida'
    else:
        raise NameError

    dialog = QDialog()
    dialog.setWindowTitle('Datos de tu {tipo_consulta} para la variable dasométrica consultada')

    layout = QVBoxLayout()

    # Texto explicativo
    label_explicativo1 = QLabel('Aquí puedes proporcionar datos tuyos para compararlos con los proporcionados\npor la consulta que has heho de la variable dasométrica dasolidar')
    label_explicativo2 = QLabel('Las diferencias pueden deberse a multiples motivos y queremos contrastar\nla información de forma individualizada, valorando la calidad de las fuentes.')
    layout.addWidget(label_explicativo1)
    layout.addWidget(label_explicativo2)

    # Especie (desplegable)
    especie_label = QLabel('Selecciona la especie:')
    layout.addWidget(especie_label)
    especie_combo = QComboBox()
    especie_combo.addItems(lista_especie_nombre_2L)
    # for key, value in dict_especies.items():
    #     especie_combo.addItem(f'{value} ({key})')
    #     especie_combo.addItem({key)
    especie_combo.setCurrentIndex(num_especie_preseleccionada)
    # especie_combo.setCurrentText(cod_2L_especie)
    layout.addWidget(especie_combo)

    # Tipo de variable (desplegable)
    tipo_variable_label = QLabel('Selecciona la variable dasométrica (o metrica lidar):')
    layout.addWidget(tipo_variable_label)
    tipo_variable_combo = QComboBox()
    tipo_variable_combo.addItems(mis_variables_nombre)
    tipo_variable_combo.setCurrentText(nombre_variable_explicada)
    layout.addWidget(tipo_variable_combo)

    # Valor (entrada numérica)
    valor_label = QLabel('Introduce el valor:')
    layout.addWidget(valor_label)
    valor_input = QLineEdit()
    valor_input.setValidator(QDoubleValidator())  # Solo permite números
    layout.addWidget(valor_input)

    # Unidad (desplegable)
    unidad_label = QLabel('Selecciona la unidad:')
    layout.addWidget(unidad_label)
    unidad_combo = QComboBox()
    unidad_combo.addItems(mis_variables_unidad)
    layout.addWidget(unidad_combo)
    otra_unidad_global = 'm3/ha'

    publicar_en_red_social_checkbox = QCheckBox('Publicar los datos aportados en dasonet')
    publicar_en_red_social_checkbox.setChecked(True)
    layout.addWidget(publicar_en_red_social_checkbox)
# ç

    # Cuadro de texto (varias líneas)
    texto_multilinea_label = QLabel('Comentarios adicionales:')
    layout.addWidget(texto_multilinea_label)
    texto_multilinea_input = QTextEdit()
    layout.addWidget(texto_multilinea_input)

    # Botones
    button_box = QDialogButtonBox()
    enviar_button = button_box.addButton('Enviar', QDialogButtonBox.AcceptRole)
    cancelar_button = button_box.addButton('Cancelar', QDialogButtonBox.RejectRole)
    layout.addWidget(button_box)

    # Conectar botones
    enviar_button.clicked.connect(dialog.accept)
    cancelar_button.clicked.connect(dialog.reject)

    # Función para actualizar las unidades según la variable seleccionada
    def actualizar_unidades():
        unidad_combo.clear()  # Limpiar las unidades anteriores
        tipo_variable = tipo_variable_combo.currentText()
        indice = mis_variables_nombre.index(tipo_variable)
        mis_variables_unidad_reordenada = [mis_variables_unidad[indice]] + mis_variables_unidad[:indice] + mis_variables_unidad[indice + 1:]
        unidad_combo.addItems(mis_variables_unidad_reordenada)

    def revisar_unidad():
        global otra_unidad_global
        tipo_unidad = unidad_combo.currentText()
        otra_unidad = tipo_unidad
        if tipo_unidad == 'otra':
            entrada_texto_dialogo = QDialog()
            entrada_texto_dialogo.setWindowTitle('Especifica la unidad')

            layout_texto = QVBoxLayout()
            label_texto = QLabel('Por favor, introduce la unidad utilizada:')
            layout_texto.addWidget(label_texto)

            entrada_texto = QLineEdit()
            layout_texto.addWidget(entrada_texto)

            button_box_texto = QDialogButtonBox()
            aceptar_button = button_box_texto.addButton('Aceptar', QDialogButtonBox.AcceptRole)
            cancelar_button = button_box_texto.addButton('Cancelar', QDialogButtonBox.RejectRole)
            layout_texto.addWidget(button_box_texto)

            entrada_texto_dialogo.setLayout(layout_texto)

            # Conectar botones
            aceptar_button.clicked.connect(entrada_texto_dialogo.accept)
            cancelar_button.clicked.connect(entrada_texto_dialogo.reject)

            # Mostrar el diálogo
            if entrada_texto_dialogo.exec_() == QDialog.Accepted:
                otra_unidad = entrada_texto.text()
                print(f'Otra unidad: {otra_unidad}')
            else:
                print('Otra unidad cancelada.')
        otra_unidad_global = otra_unidad
        return otra_unidad

    # Conectar la señal de cambio de índice
    tipo_variable_combo.currentIndexChanged.connect(actualizar_unidades)
    unidad_combo.currentIndexChanged.connect(revisar_unidad)
    # # Llamar a la función para inicializar las unidades al inicio
    # actualizar_unidades()

    # Establecer el layout en el diálogo
    dialog.setLayout(layout)

    # Establecer el foco en el campo de entrada de valor
    valor_input.setFocus()

    # Mostrar el diálogo
    # dialog.exec_()
    if dialog.exec_() == QDialog.Accepted:
        # Aquí puedes manejar los datos ingresados
        especie = especie_combo.currentText()
        tipo_variable = tipo_variable_combo.currentText()
        if tipo_variable in dict_cod_variables_dasometricas_inverso.keys():
            cod_variable = dict_cod_variables_dasometricas_inverso[tipo_variable]
        else:
            cod_variable = 'error'

        publicar_datos = publicar_en_red_social_checkbox.isChecked()
        valor = valor_input.text()
        unidad = unidad_combo.currentText()
        texto_adicional = texto_multilinea_input.toPlainText()
        # Modifico texto_adicional para incluir 'Comentario', número de línea y la línea
        lineas = texto_adicional.splitlines()
        texto_adicional_modificado = ''
        for i, linea in enumerate(lineas, start=1):
            if linea == '':
                continue
            texto_adicional_modificado += f'Obs;{i:02};{linea}\n'
        # if texto_adicional_modificado == '':
        #     texto_adicional_modificado += f'\n'

        if unidad == 'otra':
            unidad = otra_unidad_global
        print(f'Tipo: Especie: {especie}, tipo_variable: {tipo_variable}, Valor: {valor}, Unidad: {unidad}, Comentarios: {texto_adicional}')
        return (True, [especie, tipo_variable, valor, unidad, texto_adicional_modificado, publicar_datos])
    else:
        return (False, [])


def guardar_datos_parcela_rodal_en_V(
        cuerpo='',
        motivo='consulta',
    ):
    unidad_v_path = 'V:/MA_SCAYLE_VueloLidar'
    mensajes_path = os.path.join(unidad_v_path, 'dasoraster')
    unidad_V_disponible = chekear_unidad_V(unidad_v_path, mensajes_path)
    msg_filename = os.path.join(mensajes_path, f'{motivo}s.dsl')
    msg_obj = abrir_fichero_almacen(unidad_V_disponible, msg_filename)
    msg_guardado_ok = False
    if msg_obj:
        try:
            msg_obj.write(cuerpo)
            msg_obj.close()
            print(f'betaraster-> msg_guardado_ok: {msg_guardado_ok}')
            msg_guardado_ok = True
        except Exception as e:
            print(f'betaraster-> Error al guardar el mensaje en {msg_filename}')
            print(f'betaraster-> Error: {e}')
    return msg_guardado_ok

def enviar_mail_datos_parcela_rodal_consulta(
    cuerpo='',
    motivo='consulta',
    usuario_actual=usuario_actual,
    destinatario=EMAIL_DASOLIDAR1,
    asunto='dsld',
    adjunto=None,
    publicar_datos=False,
    # borrar_todo=False,
):
    mail_enviado_ok = False
    if motivo == 'bengi' or motivo == 'vega':
        motivacion = 'consulta'
    else:
        motivacion = motivo
    try:
        outlook = win32com.client.Dispatch('Outlook.Application')
        mail = outlook.CreateItem(0)
        mail.To = destinatario
        if asunto == 'dsld':
            mail.Subject = f'dsld_{motivo}_{usuario_actual}'
        else:
            mail.Subject = asunto
        mail.Body = cuerpo
        if adjunto:
            mail.Attachments.Add(adjunto)
            print(f'betaraster-> Fichero adjunto ok: {adjunto}')
        else:
            print(f'betaraster-> Mail sin adjunto')
        mail.Send()
        print(f'betaraster-> Mensaje enviado ok a {destinatario}')
        mail_enviado_ok = True
    except Exception as mi_error:
        print(f'betaraster-> Ocurrió un error al enviar el mail: {mi_error}')
        if motivo == 'sugerencia' or motivo == 'bengi':
            QMessageBox.information(
                iface.mainWindow(),
                f'{motivacion} dasolidar',
                f'No ha sido posible registrar tu {motivacion}.'
                f'\nEsta utilidad solo funciona dentro de la intranet de la JCyL.'
                f'\nSi quieres hacer una {motivacion} puedes enviar'
                f'\nun correo electrónico a {destinatario}'
            )
        return mail_enviado_ok
    iface.messageBar().pushMessage(
        title='dasoraster',
        text=f'Has enviado un correo electrónico con info de {motivacion} a {destinatario}.',
        duration=5,
        level=Qgis.Info,
    )
    if motivo == 'sugerencia' or motivo == 'bengi':
        QMessageBox.information(
            iface.mainWindow(),
            f'{motivacion} dasolidar',
            f'Muchas gracias por tu {motivacion}.'
            f'\nIntentaremos responder lo antes posible.'
            f'\nLo haremos preferentemente por correo electrónico.'
            f'\nTu e-mail: {usuario_actual}@jcyl.es'
        )
    if motivo == 'parcela' or motivo == 'rodal':
        if publicar_datos:
            texto_dasonet = f'Podrás ver tu {motivo} en dasonet en uno o dos minutos.\n'\
                'Por el momento, dasonet son dos capas ubicadas\n'\
                'en el grupo de capas "dasonet" del proyecto lidarQgis.'
        else:
            texto_dasonet = ''
        QMessageBox.information(
            iface.mainWindow(),
            f'Datos de contraste de {motivo} dasolidar enviados.',
            f'Muchas gracias por tu aportación.\n\n'\
            f'{texto_dasonet}'
        )
    if motivo == 'dasonet':
        QMessageBox.information(
            iface.mainWindow(),
            f'{motivacion} dasolidar',
            f'Muchas gracias por colaborar en este proyecto.'
            f'\nIntentaremos atender tu petición de modificación/borrado lo antes posible.'
            f'\nTe mandaremos un correo electrónico para confirmarlo.'
            f'\nTu e-mail: {usuario_actual}@jcyl.es'
        )
    return mail_enviado_ok

def pedir_guardar_enviar_data(
    tipo_consulta,
    resultado_msg,
    x_consulta,
    y_consulta,
    parcela_circular,
    radio_parcela,
    rodal_hectareas,
    layer_raster_XXX_name_txt,
    valor_medio,
    unidad_dasolidar,
    num_pixeles,
    cod_2L_especie,
    cod_modelo_txt,
    cod_variable_explicada,
    cod_num_asimilada_sp_,
    cod_estratozona_txt,
    rodal_feat=None,
    layer_crs=None,
):
    print('Botón [Aportar datos de contraste] presionado. Se pide al usuario que aporte datos de parcela/rodal')
    hoy_AAAAMMDD = datetime.fromtimestamp(time.time()).strftime('%Y%m%d')
    ahora_HHMMSS = datetime.fromtimestamp(time.time()).strftime('%H:%M:%S')
    ahora_H_M_SS = datetime.fromtimestamp(time.time()).strftime('%H%M%S')
    if tipo_consulta == 'rodal':
        print(f'Rodal consultado: se guarda su geometría.')
        unidad_v_path = 'V:/MA_SCAYLE_VueloLidar'
        mensajes_path = os.path.join(unidad_v_path, 'dasoraster')
        unidad_V_disponible = chekear_unidad_V(unidad_v_path, mensajes_path)
        if unidad_V_disponible:
            geojson_filepath = os.path.join(mensajes_path, f'dsld_{tipo_consulta}_{usuario_actual}')
            geojson_filename = f'RODAL_{tipo_consulta}_{usuario_actual}_{hoy_AAAAMMDD}_{ahora_H_M_SS}.geojson'
            if not os.path.exists(geojson_filepath):
                os.makedirs(geojson_filepath) 
            geojson_pathname = os.path.join(geojson_filepath, geojson_filename)
            rodal_geom = rodal_feat.geometry()
            fields = rodal_feat.fields()
            attributes = rodal_feat.attributes()
            writer = QgsVectorFileWriter(geojson_pathname, 'UTF-8', fields, QgsWkbTypes.Polygon, layer_crs, 'GeoJSON')
            feature = QgsFeature()
            feature.setGeometry(rodal_geom)
            feature.setAttributes(attributes)
            writer.addFeature(feature)
            del writer
            print(f'La geometría se ha guardado en: {geojson_pathname}')
        else:
            print(f'Unidad V no disponible: {mensajes_path}')
            geojson_pathname = ''
    else:
        geojson_pathname = ''

    (enviar_ok, datos_recibidos) = pedir_datos_parcela_rodal(
        tipo_consulta,
        cod_variable_explicada,
        cod_num_asimilada_sp_,
    )
    if enviar_ok:
        [especie_aportada, variable_aportada, valor_aportado, unidad_aportada, texto_adicional_modificado, publicar_datos] = datos_recibidos
    else:
        [especie_aportada, variable_aportada, valor_aportado, unidad_aportada, texto_adicional_modificado, publicar_datos] = ['Xx', 'nodata', 0, 'nodata', '', False]
        return
    texto_codificado_consulta = f'COD332;{usuario_actual};{hoy_AAAAMMDD};{ahora_HHMMSS}\n'
    texto_codificado_consulta += f'{tipo_consulta};{x_consulta:0.1f};{y_consulta:0.1f}'\
                                 f';{parcela_circular};{radio_parcela};{rodal_hectareas};{num_pixeles}'\
                                 f';{layer_raster_XXX_name_txt};{valor_medio};{unidad_dasolidar}'\
                                 f';{especie_aportada};{variable_aportada};{valor_aportado};{unidad_aportada}'\
                                 f';{publicar_datos}\n'\
                                 f'{texto_adicional_modificado}\n'

    msg_guardado_ok = guardar_datos_parcela_rodal_en_V(
        cuerpo=texto_codificado_consulta,
        motivo=tipo_consulta,
    )

    mail_enviado_ok = enviar_mail_datos_parcela_rodal_consulta(
        cuerpo=texto_codificado_consulta,
        motivo=tipo_consulta,
        adjunto=geojson_pathname,
        publicar_datos=publicar_datos,
    )

    if not msg_guardado_ok and not mail_enviado_ok:
        QMessageBox.information(
            iface.mainWindow(),
            f'Contraste {tipo_consulta} dasolidar',
            f'No ha sido posible registrar los datos de tu {tipo_consulta}.'
            f'\nEsta utilidad solo funciona dentro de la intranet de la JCyL.'
            f'\nSi quieres remitir datos manualmente puedes enviar'
            f'\nun correo electrónico a {EMAIL_DASOLIDAR1}'
        )
    elif not mail_enviado_ok:
        QMessageBox.information(
            iface.mainWindow(),
            f'Contraste {tipo_consulta} dasolidar',
            f'No ha sido posible enviar por mail los datos de tu {tipo_consulta}.'
            f'\nPuede ser debido a que Outlook no se está ejecutando en tu ordenador.'
            f'\nPero éstos han quedado registrados en el fichero de datos dasolidar que se revisa periódicamente.'
            f'\nDe todas formas, si quieres que el equipo dasolidar reciba también los datos por mail,'
            f'\npuedes enviar un correo electrónico a {EMAIL_DASOLIDAR1}'
        )
    elif not msg_guardado_ok:
        QMessageBox.information(
            iface.mainWindow(),
            f'Contraste {tipo_consulta} dasolidar',
            f'Los datos de tu {tipo_consulta} se han enviado a {EMAIL_DASOLIDAR1}.'
            f'Sin embargo, no ha sido posible guardarlos en el fichero de datos dasolidar.'
            f'\nEsta utilidad solo funciona dentro de la intranet de la JCyL.'
            f'\nSi quieres informar de esta circustancia puedes enviar'
            f'\nun correo electrónico a {EMAIL_DASOLIDAR1}'
        )

    # Refrescar aqui? No me funciona el refresco
    try:
        layer_dasonet = QgsProject.instance().mapLayersByName('dasonet_puntos')[0]
        def refrescar_canvas():
            """Función para refrescar el canvas."""
            iface.mapCanvas().refresh()  # Refresca el canvas
        # Conectar la señal de la capa a un slot
        # La conexión hay que hacerla en el constructor de tu clase o en la inicialización del plugin.
        # Puedo hacerlo solo cuando se ha enviado un polígono
        print(f'betaraster-> Se refrescará el canvas cuando cambie la capa dasonet_puntos -> layer_dasonet: {layer_dasonet}')
        layer_dasonet.featureAdded.connect(refrescar_canvas)
    except:
        pass



def mostrar_resultado(
        tipo_consulta,
        resultado_msg,
        x_consulta,
        y_consulta,
        parcela_circular,
        radio_parcela,
        rodal_hectareas,
        layer_raster_XXX_name_txt,
        valor_medio,
        unidad_dasolidar,
        num_pixeles,
        cod_2L_especie,
        cod_modelo_txt,
        cod_variable_explicada,
        cod_num_asimilada_sp_,
        cod_estratozona_txt,
        rodal_feat=None,
        layer_crs=None,
    ):
    # Crear un QDialog
    dialog = QDialog()
    dialog.setWindowTitle(f'Consulta dasométrica: {tipo_consulta}')

    # Crear un layout vertical
    layout = QVBoxLayout()

    # Agregar un QLabel para el mensaje
    label = QLabel(resultado_msg)
    layout.addWidget(label)

    # Crear el botón de 'OK'
    ok_button = QPushButton('OK')
    ok_button.setToolTip('No enviar datos de contraste.')  # Tooltip para el botón OK
    ok_button.clicked.connect(dialog.accept)  # Cerrar el diálogo al hacer clic
    layout.addWidget(ok_button)

    # Crear el botón de 'Enviar'
    enviar_button = QPushButton('Aportar datos de contraste')
    enviar_button.setToolTip('Pulsa este botón si dispones de datos en esta misma ubicación\ny quieres compartirlos con los coordinadores del proyecto dasolidar.\n\nEsto nos permitirá detectar modelos que no dan buenas estimaciones y mejorarlos.\nLos modelos son específicos de cada especie y zona y tus aportaciones\nnos ayudan a detectar estratos y parámetros que hay que revisar.')
    
    # Conecto el botón a la función y cierro el diálogo
    enviar_button.clicked.connect(
        lambda: (
            dialog.accept(),  #  Cierro el diálogo inmediatamente
            QTimer.singleShot(0, lambda: pedir_guardar_enviar_data(  #  Llamo a la función después de cerrar el diálogo
                tipo_consulta,
                resultado_msg,
                x_consulta,
                y_consulta,
                parcela_circular,
                radio_parcela,
                rodal_hectareas,
                layer_raster_XXX_name_txt,
                valor_medio,
                unidad_dasolidar,
                num_pixeles,
                cod_2L_especie,
                cod_modelo_txt,
                cod_variable_explicada,
                cod_num_asimilada_sp_,
                cod_estratozona_txt,
                rodal_feat=rodal_feat,
                layer_crs=layer_crs,
            ))
        )
    )
    
    layout.addWidget(enviar_button)

    # Establecer el layout en el diálogo
    dialog.setLayout(layout)

    # Mostrar el diálogo
    dialog.exec_()


class Dasoraster:
    '''QGIS Plugin Implementation.'''

    def __init__(self, iface):
        '''Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        '''
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = iface.mapCanvas()
        self.tool_parcela = None
        self.autoCargaLasFileObj = None
# ç
        settings = QSettings()
        self.radio_parcela = settings.value('dasoraster/radio_parcela', 15, type=float)
        self.parcela_circular = settings.value('dasoraster/parcela_circular', True, type=bool)
        self.consulta_multiple = settings.value('dasoraster/consulta_multiple', True, type=bool)
        self.buscar_modelo_regresion = settings.value('dasoraster/buscar_modelo_regresion', False, type=bool)
        self.buscar_esp_mfe = settings.value('dasoraster/buscar_esp_mfe', True, type=bool)
        # self.autocarga_lasfiles = settings.value('dasoraster/autocarga_lasfiles', type=bool)
        self.autocarga_lasfiles = False
        self.autocarga_escala_maxima = settings.value('dasoraster/autocarga_escala_maxima', AUTOCARGA_ESCALA_MAXIMA_RECOMENDADA, type=int)
        # self.autocarga_mostrar_lasfiles_en_leyenda = settings.value('dasoraster/autocarga_mostrar_lasfiles_en_leyenda', True, type=bool)
        # self.lector_pdf_windows = settings.value('dasoraster/lector_pdf_windows', True, type=bool)
        self.lector_pdf_windows = True

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            PLUGIN_DIR,
            'i18n',
            'Dasoraster_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Dasoraster')

        # TODO: We are going to let the user set this up in a future iteration  #  #new (mensaje de Plugin builder)
        self.toolbar = self.iface.addToolBar(u'dasoraster')  #  #new
        self.toolbar.setObjectName(u'dasoraster')  #  #new

        self.pluginIsActive = False  #  #new
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start_run = None
        self.first_start_consulta_rodal = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        '''Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        '''
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Dasoraster', message)

    def mensaje(self, mi_text='', mi_title='dasoraster', mi_showMore=None, mi_duration=15, mi_level=Qgis.Info):
        if mi_showMore is None or type(mi_showMore) != str:
            self.iface.messageBar().pushMessage(
                title=mi_title,
                text=mi_text,
                duration=mi_duration,
                level=mi_level,
            )
        else:
            self.iface.messageBar().pushMessage(
                title=mi_title,
                text=mi_text,
                showMore=mi_showMore,
                duration=mi_duration,
                level=mi_level,
            )

    def add_action(
        self,
        icon_path,
        text,
        callback,
        checkable=False,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        '''Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        '''

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setCheckable(checkable)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            # self.iface.addToolBarIcon(action)
            self.toolbar.addAction(action)  #  #new

        if add_to_menu:
            # self.iface.addPluginToRasterMenu(  #  #new
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        '''Create the menu entries and toolbar icons inside the QGIS GUI.'''

        # Atribucion iconos de flaticon:
        # <a href="https://www.flaticon.es/iconos-gratis/meta" title="meta iconos">Meta iconos creados por Rooman12 - Flaticon</a>
        # La ruta :/plugins se establece dentro de Qgis en: Configuración -> Opciones -> Sistema
        # QGIS_PLUGINPATH = D:/_clid/dasolidar/dasolidar

        icon_path = ':/plugins/dasoraster/resources/images/icon_dasolidar.png'
        self.action1 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n    lasFile'),
            callback=self.cargar_lasfile,
            parent=self.iface.mainWindow(),
            checkable=True,
        )

        icon_path = ':/plugins/dasoraster/resources/images/icon_parcela.png'
        self.action2 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n   parcela'),
            callback=self.consultar_parcela,
            parent=self.iface.mainWindow(),
            checkable=True,
        )

        icon_path = ':/plugins/dasoraster/resources/images/icon_rodal.png'
        self.action3 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n     rodal'),
            callback=self.consultar_rodal,
            parent=self.iface.mainWindow(),
            checkable=True,
        )

        icon_path = ':/plugins/dasoraster/resources/images/icon_explorer.png'
        self.action4 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n lidarData'),
            callback=self.explorar_ldata,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/resources/images/icon_guiaRapida.png'
        self.action5 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\nguia rápida'),
            callback=self.guia_rapida_dasolidar,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/resources/images/icon_book.png'
        self.action6 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n   manual'),
            callback=self.manual_dasolidar,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/resources/images/icon_star.png'
        self.action7 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\nConsultas & IA'),
            callback=self.dasolidar_IA,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/resources/images/icon_config.png'
        self.action_settings = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n  settings'),
            callback=self.dasoraster_settings,
            parent=self.iface.mainWindow(),
        )

        if usuario_alfa:
            icon_path = ':/plugins/dasoraster/resources/images/icon_arbol.png'
            self.action_extra = self.add_action(
                icon_path,
                # text=self.tr(u'dasoraster\n carga Lidar automática'),
                text=self.tr(u'dasoraster\n acción extra'),
                callback=self.dasoraster_extra,
                parent=self.iface.mainWindow(),
            )
            self.action_extra.setEnabled(True)
            self.active_extra = False

        # Pasan a False la primera vez que se invoca cada herramienta
        self.first_start_run = True
        self.first_start_consulta_rodal = True

    def unload(self):
        '''Removes the plugin menu item and icon from QGIS GUI.'''

        # Primero elimino los las entradas de menu y los iconos
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Dasoraster'), action)
            self.iface.removeToolBarIcon(action)

        # A continuaión elimino la barra de herramientas
        try:
            if self.toolbar is not None:
                self.iface.mainWindow().removeToolBar(self.toolbar)
        except:
            pass

        # Esto es por si se desinstala el plugin teniendo todavía activado el autoCargaLasFile
        # No estoy seguro de que se pueda desconectar estasdos señales con este código, así que uso el try - except
        try:
            if self.autoCargaLasFileObj:
                if self.canvas:
                    self.canvas.mapCanvasRefreshed.disconnect(self.autoCargaLasFileObj.on_canvas_changed)
                    self.canvas.scaleChanged.disconnect(self.autoCargaLasFileObj.on_scale_changed)
        except:
            print(f'betaraster-> No se pueden desconectar las señales asociadas a mapCanvasRefreshed y a scaleChanged')

        self.toolbar = None
        self.actions = []

    def run(self):
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start_run == True:
            self.first_start_run = False
            self.dlg_run = DasorasterDialog()

        # show the dialog
        self.dlg_run.show()
        # Run the dialog event loop
        result = self.dlg_run.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def manejar_clic_canvas(
            self,
            punto_click,
            boton_click,
            tipo_consulta='',
            # raster_dataset_selec=None,
            # raster_array=None,
    ):
        self.boton_click = boton_click
        self.punto_click = punto_click
        print(f'betaraster-> punto_click 1: ({type(punto_click)}): {punto_click}')  #  (<class 'qgis._core.QgsPointXY'>): <QgsPointXY: POINT(260290 4739779)>
        # Podría usar el parametro boton_click para diferenciar entre diferentes tipos de clics si fuera necesario

        if tipo_consulta == 'lasfile':
            # Obtener la capa de nube de puntos
            self.malla_disponible, self.layer_selec = capa_malla_lasfiles()
            if not self.malla_disponible or self.layer_selec is None:
                iface.messageBar().pushMessage(
                    title='dasoraster',
                    text=f'La descarga manual de ficheros Lidar no está disponible en este proyecto o ubicación',
                    # showMore=f'',
                    duration=15,
                    level=Qgis.Warning,
                )
                return False
        elif tipo_consulta == 'rodal':
            self.layer_selec = capa_vector_activa()
        if not self.layer_selec:
            return False

        print(f'betaraster-> layer identificado: {self.layer_selec}')

        # Compruebo el CRS del self.layer_selec
        self.layer_crs = self.layer_selec.crs()
        print(f'betaraster-> CRS del self.layer_selec: {self.layer_crs.authid()}')
        # Defino el CRS del punto (EPSG:25830)
        point_crs = QgsCoordinateReferenceSystem('EPSG:25830')
        if self.layer_crs != point_crs:
            # Transformar el punto al CRS del self.layer_selec
            if self.layer_crs.authid() in ['EPSG:25829', 'EPSG:25830']:
                transform = QgsCoordinateTransform(point_crs, self.layer_crs, QgsProject.instance())
                transformed_punto_click = transform.transform(punto_click)
                print(f'betaraster-> Punto transformado: {transformed_punto_click.x()}, {transformed_punto_click.y()}')
            else:
                print(f'betaraster-> El self.layer_selec no está en EPSG:25829 ni EPSG:25830: {self.layer_crs}.')
                transformed_punto_click = punto_click
                iface.messageBar().pushMessage(
                    title='dasoraster',
                    text=f'Parece que la capa consultada no tiene el siste de referencia de coordenadas adecuado.\n Se asume que EPSG 25830.',
                    # showMore=f'',
                    duration=10,
                    level=Qgis.Info,
                )
                # return False
            # punto_click = QgsPointXY(X, Y)
            print(f'betaraster-> Se han convertido las coordenadas del punto (EPSG:25830) al crs del layer vectorial:')
            print(f'betaraster-> punto_click original {point_crs.authid()}-> {punto_click}')
            print(f'betaraster-> punto_click transfor {self.layer_crs.authid()}-> {transformed_punto_click}')
        else:
            transformed_punto_click = punto_click

        if self.layer_selec and self.layer_selec.type() == QgsMapLayer.VectorLayer:
            ajustar_escala_lasfile(transformed_punto_click)
            selected_features = seleccionar_bloques(
                transformed_punto_click,
                self.layer_selec,
            )
        else:
            selected_features = None

        if selected_features:
            # Convertir el iterador a una lista para contar las características
            features_list = list(selected_features)
            # Contar el número de características
            num_features = len(features_list)
            print(f'betaraster-> Número de poligonos seleccionados-> {num_features}')
            if num_features == 0:
                resultado_msg = f'La capa consultada ({self.layer_selec.name()}) no tiene ningún polígono en ese punto'
                QMessageBox.information(
                    self.iface.mainWindow(),
                    f'Consulta dasolidar: {tipo_consulta}',
                    resultado_msg,
                )

            for feature in features_list:
                if tipo_consulta == 'lasfile':
                    print(f'betaraster-> ID: {feature.id()}, COPC1: {feature["COPC1"]}')
                    # Obtener el valor del campo COPC1
                    copc_1_value = feature['COPC1']
                    copc_2_value = feature['COPC2']
                    copc_any_value = feature['COPC_ANY']
                    cuadrante_1_value = feature['Cuadrante']
                    cuadrante_2_value = feature['Cuadrante2']
                    copc_CE_value = feature['COPC_CE']
                    copc_NE_value = feature['COPC_NE']
                    copc_NW_value = feature['COPC_NW']
                    copc_SE_value = feature['COPC_SE']
                    copc_SW_value = feature['COPC_SW']
                    print(f'betaraster-> copc_value {type(copc_1_value)}: {copc_1_value}')
                    if not type(copc_1_value) == str:
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text=f'Aviso: código pendiente de revisar. Informar de este aviso al autor de este complemento ({EMAIL_DASOLIDAR1}).',
                            # showMore=f'',
                            duration=30,
                            level=Qgis.Warning,
                        )
                    elif 'Aviso' in copc_1_value:
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text=copc_1_value,
                            # showMore=f'',
                            duration=30,
                            level=Qgis.Warning,
                        )
                    else:
                        # Verifico si COPC no es NULL y el archivo existe
                        (carga_ok, copcLazFile_path_name_ok) = cargar_nube_de_puntos(
                            copc_1_value,
                            copc_2_value,
                            copc_any_value,
                            cuadrante_1_value,
                            cuadrante_2_value,
                            copc_CE_value,
                            copc_NE_value,
                            copc_NW_value,
                            copc_SE_value,
                            copc_SW_value,
                            # autocarga_mostrar_lasfiles_en_leyenda=True,
                            verboseLocal=True,
                        )

                elif tipo_consulta == 'rodal':
                    print(f'betaraster-> Feature id: {feature.id()}')
                    self.rodal_feat = feature
                    self.tool_rodal.rubberBand.setToGeometry(self.rodal_feat.geometry(), self.layer_selec)
                    self.tool_rodal.rubberBand.setColor(QColor(255, 0, 0, 100))  # Color rojo con transparencia
                    self.tool_rodal.rubberBand.setWidth(2)

                    self.obtener_volumen(
                        self.punto_click,
                        self.boton_click,
                        tipo_consulta='rodal',
                        rodal_feat=self.rodal_feat,
                        # layer_rodales=None,
                        # raster_dataset_volumen=raster_dataset_selec,
                        # raster_array=raster_array,
                    )

                break  # Salir después de encontrar el primer polígono que contiene el punto
        else:
            print(f'betaraster-> No se encontró ningún polígono que contenga el punto (o la capa es ráster).')


    def cargar_lasfile(self):
        print(f'betaraster-> self.action1.isChecked() 1: {self.action1.isChecked()}')
        if self.action2.isChecked():
            self.action2.setChecked(False)
        if self.action3.isChecked():
            self.action3.setChecked(False)

        if self.action1.isChecked():
            self.tool_cargar_lasf = QgsMapToolEmitPoint(iface.mapCanvas())
            # Conecto la señal de clic en el canvas a la función que maneja el clic
            # self.tool_cargar_lasf.canvasClicked.connect(self.manejar_clic_canvas)
            # Lo hago trasferiéndole parémtros (event, button y tipo_consulta) para aprovechar la función manejar_clic_canvas<>
            self.tool_cargar_lasf.canvasClicked.connect(
                lambda event, boton_click: self.manejar_clic_canvas(
                    event,
                    boton_click,
                    tipo_consulta='lasfile',
                )
            )
            # print(f'betaraster-> self.action1.isChecked() 2: {self.action1.isChecked()}')
            # Establezco la herramienta de mapa actual
            iface.mapCanvas().setMapTool(self.tool_cargar_lasf)
            # print(f'betaraster-> self.action1.isChecked() 3: {self.action1.isChecked()}')
        else:
            try:
                print(f'betaraster-> No elimino el cursor de descarga')
                self.canvas.unsetMapTool(self.tool_cargar_lasf)
            except Exception as mi_error:
                print(f'betaraster-> Error:  {mi_error}')
            self.action1.setChecked(False)

    def consultar_parcela(self):
        print(f'betaraster-> self.action2.isChecked() 1: {self.action2.isChecked()}')
        if self.action1.isChecked():
            self.action1.setChecked(False)
        if self.action3.isChecked():
            self.action3.setChecked(False)

        escala_actual = self.canvas.scale()
        print(f'betaraster-> Escala del mapa: {escala_actual}')
        if escala_actual > 100000 / self.radio_parcela:
            print(f'betaraster-> Escala insuficiente para ver la parcela')
            iface.messageBar().pushMessage(
                title='dasoraster',
                text=f'Amplia la escala del mapa para poder ver la parcela de {self.radio_parcela} metros de radio.',
                # showMore=f'',
                duration=10,
                level=Qgis.Info,
            )
        # if self.consulta_multiple:
        #     pass
        #     # if self.action2.isChecked():
        #     #     self.action2.setChecked(True)
        #     # else:
        #     #     self.action2.setChecked(False)
        # else:
        #     self.action2.setChecked(True)
        print(f'betaraster-> self.action2.isChecked() 2: {self.action2.isChecked()}')
        if self.action2.isChecked():
            # self.tool_parcela = QgsMapToolEmitPoint(self.canvas)
            self.tool_parcela = CustomMapTool(
                self.canvas,
                self.radio_parcela,
                self.parcela_circular,
                self.consulta_multiple,
            )
            # self.tool_parcela.canvasClicked.connect(self.obtener_volumen)
            self.tool_parcela.canvasClicked.connect(
                lambda event, boton_click: self.obtener_volumen(
                    event,
                    boton_click,
                    tipo_consulta='parcela',
                )
            )
            self.canvas.setMapTool(self.tool_parcela)
            print(f'betaraster-> self.action2.isChecked() 3: {self.action2.isChecked()}')
            if not self.consulta_multiple:
                self.action2.setChecked(False)
        else:
            try:
                print(f'betaraster-> Elimino trazado de la parcela (a)')
                self.tool_parcela.rubber_band.reset(QgsWkbTypes.PolygonGeometry)
                self.canvas.unsetMapTool(self.tool_parcela)
            except Exception as mi_error:
                print(f'betaraster-> Error:  {mi_error}')
            self.action2.setChecked(False)
            print(f'betaraster-> self.action2.isChecked() 4: {self.action2.isChecked()}')

    def consultar_rodal(self):
        print(f'betaraster-> self.action3.isChecked() 1: {self.action3.isChecked()}')
        if self.action1.isChecked():
            self.action1.setChecked(False)
        if self.action2.isChecked():
            self.action2.setChecked(False)

        print(f'betaraster-> Se ha pulsado el botón consultar_rodal')
        raster_path = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\PNOA2_2017 - 2021\variablesDasometricas\version_202411'
        raster_filename_1 = 'dasoLidar_VolumenMadera_m3_ha.tif'
        raster_filename_2 = 'dasoLidar_VolumenMadera_m3_ha_EPSG25830'
        raster_filepath = os.path.join(raster_path, raster_filename_1)
        if not os.path.exists(raster_filepath):
            raster_filepath = os.path.join(raster_path, raster_filename_2)
            if not os.path.exists(raster_filepath):
                raster_path = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\varios\cocina'
                raster_filepath = os.path.join(raster_path, raster_filename_1)
                if not os.path.exists(raster_filepath):
                    iface.messageBar().pushMessage(
                        title='dasoraster',
                        text=f'Aviso: No se ha encontrado la capa {raster_filename_1}. Contactar con los responsables del proyecto dasolidar (revisar capas dasoraster).',
                        # showMore=f'',
                        duration=20,
                        level=Qgis.Warning,
                    )
                    return
        print(f'betaraster-> Fichero VCC: {raster_filepath}')
        print(f'betaraster-> Disponible:  {os.path.exists(raster_filepath)}')

        # # Descartado el uso de gdal para leer el ráster de volúmenes
        # raster_leido_ok = False
        # if os.path.exists(raster_filepath):
        #     raster_volumen_dataset = gdal.Open(raster_filepath)
        #     print(f'betaraster-> raster_volumen_dataset: {raster_volumen_dataset}')
        #     if raster_volumen_dataset:
        #         raster_band = raster_volumen_dataset.GetRasterBand(1)
        #         # Leer el ráster como un array de numpy
        #         raster_array = raster_band.ReadAsArray()
        #         print(f'betaraster-> raster_array.shape: {raster_array.shape}')
        #         raster_leido_ok = True
        # if not raster_leido_ok:
        #     raster_volumen_dataset = None
        #     raster_array = None

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        print(f'betaraster-> self.action3.isChecked() 1: {self.action3.isChecked()}')
        # self.tool_rodal = ConsultarRodalTool(self.canvas)
        # self.tool_rodal = QgsMapToolEmitPoint(iface.mapCanvas())
        self.tool_rodal = ConsultarRodalTool(iface.mapCanvas())
        # Conecto la señal de clic en el canvas a la función que maneja el clic
        # self.tool_rodal.canvasClicked.connect(self.manejar_clic_canvas)
        self.tool_rodal.canvasClicked.connect(
            lambda event, boton_click: self.manejar_clic_canvas(
                event,
                boton_click,
                tipo_consulta='rodal',
                # raster_dataset_selec=raster_volumen_dataset,
                # raster_array=raster_array,
            )
        )
        print(f'betaraster-> self.action3.isChecked() 2: {self.action3.isChecked()}')
        # Establezco la herramienta de mapa actual
        iface.mapCanvas().setMapTool(self.tool_rodal)
        print(f'betaraster-> self.action3.isChecked() 3: {self.action3.isChecked()}')

    def buscar_raster_modelos(self, cod_variable_dasometrica):
        # Parámetros de entrada
        capa_nombre_MDL = f'modelo_{cod_variable_dasometrica}_CyL'
        capa_raster_MDL = QgsProject.instance().mapLayersByName(capa_nombre_MDL)
        capa_MDL_raster_ok = None
        if capa_raster_MDL:
            capa_MDL_raster_ok = capa_raster_MDL[0]
            capa_MDL_encontrada = True
        else:
            capa_MDL_encontrada = False
            print(f'betaraster-> Capa {capa_nombre_MDL} no encontrada')
        return capa_MDL_encontrada, capa_MDL_raster_ok, capa_nombre_MDL

    def buscar_raster_volumenes(self):
        # Parámetros de entrada
        capa_VCC_nombre_1 = 'VolumenMadera_m3_ha'
        capa_VCC_nombre_2 = 'VCC____IFNxPNOA2'
        capas_VCC = [capa_VCC_nombre_1, capa_VCC_nombre_2]
        layer_raster_VCC_find_bool = False
        layer_raster_VCC_name_txt = capa_VCC_nombre_1
        layer_raster_VCC_selec_layer = None
        for capa_VCC_nombre in capas_VCC:
            capa_raster_vcc = QgsProject.instance().mapLayersByName(capa_VCC_nombre)
            if capa_raster_vcc:
                layer_raster_VCC_find_bool = True
                layer_raster_VCC_name_txt = capa_VCC_nombre
                layer_raster_VCC_selec_layer = capa_raster_vcc[0]  #  Usar la capa 'VCC' si está cargada
                break
            else:
                print(f'betaraster-> Capa {capa_VCC_nombre} no encontrada')
        return (layer_raster_VCC_find_bool, layer_raster_VCC_name_txt, layer_raster_VCC_selec_layer)

    def buscar_raster_activo(
            self,
            layer_raster_VCC_find_bool,
            layer_raster_VCC_name_txt,
            layer_raster_VCC_selec_layer,
        ):
        layer_activo = iface.activeLayer()
        capa_activa_es_raster = False
        layer_raster_XXX_find_bool = False
        layer_raster_XXX_name_txt = ''
        layer_raster_XXX_selec_layer = None
        if layer_activo is None:
            if layer_raster_VCC_find_bool:
                print(f'betaraster-> No hay capa activa. Se usa la capa ráster de volúmenes {layer_raster_VCC_name_txt}')
                iface.messageBar().pushMessage(
                    title='dasoraster',
                    text=f'No hay capa activa. Se usa la capa ráster de volúmenes {layer_raster_VCC_name_txt}',
                    # showMore=f'',
                    duration=20,
                    level=Qgis.Info,
                )
                layer_raster_XXX_find_bool = True
                layer_raster_XXX_selec_layer = layer_raster_VCC_selec_layer
            else:
                print(f'betaraster-> No hay ninguna capa activa.')
                iface.messageBar().pushMessage(
                    title='dasoraster',
                    text=f'No se ha encontrado la capa ráster de volumen {layer_raster_VCC_name_txt} y no hay ninguna capa activa. Activa una capa ráster para poder hacer consultas.',
                    # showMore=f'',
                    duration=30,
                    level=Qgis.Warning,
                )
        else:
            if layer_activo.type() == QgsMapLayer.RasterLayer:
                print(f'betaraster-> La capa activa es una capa raster.')
                capa_activa_es_raster = True
                layer_raster_XXX_selec_layer = layer_activo
                if layer_raster_XXX_selec_layer.name() in dict_capas_variables_dasometricas.keys():
                    # cod_variable_dasometrica = dict_capas_variables_dasometricas[layer_raster_XXX_selec_layer.name()]
                    capa_activa_es_variable_dasometrica = True
                else:
                    capa_activa_es_variable_dasometrica = False
                if layer_raster_VCC_find_bool:
                    if capa_activa_es_variable_dasometrica:
                        print(f'betaraster-> Capa de volumen encontrada, pero se consulta la capa activa: {layer_activo.name()}')
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text=f'Se consulta la capa ráster activa: {layer_activo.name()}; si se quiere consultar el volumen activar capa ráster de volumen ({layer_raster_VCC_name_txt}).',
                            # showMore=f'',
                            duration=10,
                            level=Qgis.Info,
                        )
                        layer_raster_XXX_find_bool = True
                    else:
                        print(f'betaraster-> La capa activa es raster pero no corresponde a una variable dasomatrica o metrica lidar de altDomLidar.')
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text=f'La capa activa es ráster pero no es una variable dasométrica ni es la altura dominanteLidar. Se usa la capa ráster de volúmenes {layer_raster_VCC_selec_layer}',
                            # showMore=f'',
                            duration=20,
                            level=Qgis.Info,
                        )
                        layer_raster_XXX_find_bool = True
                        layer_raster_XXX_selec_layer = layer_raster_VCC_selec_layer
                else:
                    if capa_activa_es_variable_dasometrica:
                        print(f'betaraster-> Capas de volumen no encontradas; se consulta la capa activa: {layer_activo.name()}')
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text=f'No se ha encontrado la capa ráster de volumen {layer_raster_VCC_name_txt}; se consulta la capa activa: {layer_activo.name()}.',
                            # showMore=f'',
                            duration=10,
                            level=Qgis.Info,
                        )
                        layer_raster_XXX_find_bool = True
                    else:
                        print(f'betaraster-> La capa activa es raster pero no corresponde a una variable dasomatrica o metrica lidar de altDomLidar.')
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text=f'La capa activa es ráster pero no es una variable dasométrica ni es la altura dominanteLidar\ny no se ha encontrado el ráster de volúmenes {layer_raster_VCC_name_txt}. Activa una capa ráster con una variable dasométrica para poder hacer consultas.',
                            # showMore=f'',
                            duration=20,
                            level=Qgis.Info,
                        )
            else:
                if layer_activo.type() == QgsMapLayer.VectorLayer:
                    tipo_capa_activa = 'vectorial'
                else:
                    tipo_capa_activa = 'no-raster y no-vector'
                if layer_raster_VCC_find_bool:
                    print(f'betaraster-> La capa activa es {tipo_capa_activa}. Se usa la capa ráster de volúmenes {layer_raster_VCC_name_txt}')
                    iface.messageBar().pushMessage(
                        title='dasoraster',
                        text=f'La capa activa es vectorial. Se usa la capa ráster de volúmenes {layer_raster_VCC_name_txt}',
                        # showMore=f'',
                        duration=20,
                        level=Qgis.Info,
                    )
                    layer_raster_XXX_find_bool = True
                    layer_raster_XXX_selec_layer = layer_raster_VCC_selec_layer
                else:
                    print(f'betaraster-> La capa activa es vectorial y no se ha encontrado la capa ráster de volumen {layer_raster_VCC_name_txt}')
                    iface.messageBar().pushMessage(
                        title='dasoraster',
                        text=f'No se ha encontrado la capa ráster de volumen {layer_raster_VCC_name_txt} y la capa activa es vectorial. Activa una capa ráster con una variable dasométrica para poder hacer consultas.',
                        # showMore=f'',
                        duration=30,
                        level=Qgis.Warning,
                    )

        if layer_raster_XXX_selec_layer is None:
            layer_raster_XXX_name_txt = ''
        else:
            layer_raster_XXX_name_txt = layer_raster_XXX_selec_layer.name()
        return (layer_raster_XXX_find_bool, layer_raster_XXX_name_txt, layer_raster_XXX_selec_layer)

    def identifica_modelo(self):
        # Se deduce la variable dasometrica a la vista de la capa consultada
        if self.layer_raster_XXX_selec_layer.name() in dict_capas_variables_dasometricas.keys():
            cod_variable_dasometrica = dict_capas_variables_dasometricas[self.layer_raster_XXX_selec_layer.name()]
        else:
            print(f'betaraster-> self.layer_raster_XXX_selec_layer.name(): {self.layer_raster_XXX_selec_layer.name()}')
            print(f'betaraster-> dict_capas_variables_dasometricas.keys(): {dict_capas_variables_dasometricas.keys()}')
            cod_variable_dasometrica = 'DESC'
        (
            capa_MDL_encontrada, capa_MDL_raster_ok, capa_nombre_MDL
        ) = self.buscar_raster_modelos(cod_variable_dasometrica)
        if capa_MDL_encontrada:
            result_modeloDL = capa_MDL_raster_ok.dataProvider().identify(self.punto_click, QgsRaster.IdentifyFormatValue)
            if result_modeloDL.isValid():
                try:
                    cod_num_txt_modeloDL = str(int(result_modeloDL.results()[1]))  #  Acceder al valor del píxel
                except:
                    cod_num_txt_modeloDL = 'noNumero'
            else:
                cod_num_txt_modeloDL = 'noValida'
        else:
            cod_num_txt_modeloDL = 'noCapa'

        if cod_num_txt_modeloDL in dict_cod_modelo.keys():
            cod_modelo_txt = dict_cod_modelo[cod_num_txt_modeloDL][0]
            cod_variable_explicada = dict_cod_modelo[cod_num_txt_modeloDL][1]
            if cod_num_txt_modeloDL in dict_cod_modelo:
                try:
                    cod_num_txt_asimilada_sp_ = int(dict_cod_modelo[cod_num_txt_modeloDL][2])
                except:
                    print(f'betaraster-> cod_num_txt_modeloDL ({type(cod_num_txt_modeloDL)}): {cod_num_txt_modeloDL}')
                    cod_num_txt_asimilada_sp_ = 0
            else:
                print(f'betaraster-> cod_num_txt_modeloDL ({type(cod_num_txt_modeloDL)}): {cod_num_txt_modeloDL}')
                cod_num_txt_asimilada_sp_ = 0
            cod_estratozona_txt = dict_cod_modelo[cod_num_txt_modeloDL][3]
        else:
            print(f'betaraster-> cod_num_txt_modeloDL ({type(cod_num_txt_modeloDL)}): {cod_num_txt_modeloDL}')
            print(f'betaraster-> dict_cod_modelo.keys(): {dict_cod_modelo.keys()}')
            cod_modelo_txt = ''
            cod_variable_explicada = 'Xx'
            cod_num_txt_asimilada_sp_ = 0
            cod_estratozona_txt = 'x'

        return (
            capa_MDL_encontrada,
            capa_nombre_MDL,
            cod_num_txt_modeloDL,
            cod_modelo_txt,
            cod_variable_explicada,
            cod_num_txt_asimilada_sp_,
            cod_estratozona_txt,
        )

    def mostrar_especie(
            self,
            tipo_consulta,
            resultado_msg,
            capa_MFE_encontrada,
            cod_num_especie,
            cod_2L_especie,
            nombre_especie,
            cod_num_asimilada_sp_,
            dict_spp_mfe_1={},
            dict_spp_mfe_2={},
        ):
        if capa_MFE_encontrada:
            resultado_msg += f'\n\nEspecie en el punto (click):'
            if cod_num_especie == 0:
                resultado_msg += f'\n    Punto en tesela no arbolada'
            else:
                resultado_msg += f'\n    {cod_num_especie} -> {cod_2L_especie} ({nombre_especie})'
            if int(cod_num_asimilada_sp_) != cod_num_especie:
                resultado_msg += f'\nEsp. asimilada: {cod_num_asimilada_sp_}'
        else:
            resultado_msg += f'\nCapa MFE25 no disponible en el proyecto (MFE25CyL.gpkg).'
        if dict_spp_mfe_1:
            top_especies = sorted(dict_spp_mfe_1.items(), key=lambda item: item[1], reverse=True)[:2]
            resultado_msg += f'\n\nEspecies principales en {tipo_consulta}:'
            for cod_num_mfe_sp_, num_pixeles in top_especies[:3]:
                if cod_num_mfe_sp_ in dict_spp_mfe25cyl.keys():
                    cod_2L_sp_ = dict_spp_mfe25cyl[cod_num_mfe_sp_][0]
                    nombre_sp_ = dict_spp_mfe25cyl[cod_num_mfe_sp_][1]
                    # dasolidar_sp_ = dict_spp_mfe25cyl[cod_num_mfe_sp_][2]
                    # cod_num_txt_asimilada_sp_ = dict_spp_mfe25cyl[cod_num_mfe_sp_][3]
                    resultado_msg += f'\n    {cod_num_mfe_sp_} -> {cod_2L_sp_} ({nombre_sp_}): {num_pixeles} pixeles'
            if 0 in dict_spp_mfe_1.keys():
                print(f'betaraster-> dict_spp_mfe_1.keys(): {dict_spp_mfe_1.keys()} -> {0 in dict_spp_mfe_1.keys()}')
                resultado_msg += f'\n    Píxeles en teselas no arboladas: {dict_spp_mfe_1[0]}'
            if -1 in dict_spp_mfe_1.keys():
                print(f'betaraster-> dict_spp_mfe_1.keys(): {dict_spp_mfe_1.keys()} -> {-1 in dict_spp_mfe_1.keys()}')
                resultado_msg += f'\n    Pixeles erróneos (revisar): {dict_spp_mfe_1[-1]}'
        if dict_spp_mfe_2:
            hay_especies_secundarias = False
            for cod_num_mfe_sp_ in dict_spp_mfe_2.keys():
                if cod_num_mfe_sp_ != 0:
                    hay_especies_secundarias = True
            if hay_especies_secundarias:
                top_especies = sorted(dict_spp_mfe_2.items(), key=lambda item: item[1], reverse=True)[:2]
                resultado_msg += f'\n\nEspecies secundarias en el polígono:'
                for cod_num_mfe_sp_, num_pixeles in top_especies[:3]:
                    if cod_num_mfe_sp_ in dict_spp_mfe25cyl.keys():
                        cod_2L_sp_ = dict_spp_mfe25cyl[cod_num_mfe_sp_][0]
                        nombre_sp_ = dict_spp_mfe25cyl[cod_num_mfe_sp_][1]
                        # dasolidar_sp_ = dict_spp_mfe25cyl[cod_num_mfe_sp_][2]
                        # cod_num_txt_asimilada_sp_ = dict_spp_mfe25cyl[cod_num_mfe_sp_][3]
                        resultado_msg += f'\n    {cod_num_mfe_sp_} -> {cod_2L_sp_} ({nombre_sp_}): {num_pixeles} pixeles'
                # if 0 in dict_spp_mfe_2.keys():
                #     resultado_msg += f'\n    Numero de pixeles en teselas no arboladas: {dict_spp_mfe_2[0]}'
                if -1 in dict_spp_mfe_2.keys():
                    resultado_msg += f'\n    Numero de pixeles erróneos (revisar): {dict_spp_mfe_2[-1]}'
        return resultado_msg

    def mostrar_modelo(
            self,
            resultado_msg,
            capa_MFE_encontrada,
            cod_num_especie,
            mod_num_asimilada_sp_,
            capa_MDL_encontrada,
            capa_nombre_MDL,
            cod_num_txt_modeloDL,
            cod_estratozona_txt,
            cod_modelo_txt,
        ):
        if capa_MFE_encontrada:
            if cod_num_especie != mod_num_asimilada_sp_ and capa_MDL_encontrada and not cod_num_txt_modeloDL.startswith('no'):
                resultado_msg += f'\n      Especie con cod IFN {cod_num_especie} no modelizada; se asimila a la {mod_num_asimilada_sp_}'

        if type(cod_estratozona_txt) == str:
            cod_estratozona_txt_sinExtras = cod_estratozona_txt.replace('&sinHoja', '').replace('&sinUso', '')
            if cod_estratozona_txt_sinExtras in dict_zonas.keys():
                cod_estratozona_nombre = dict_zonas[cod_estratozona_txt_sinExtras][0]
            else:
                cod_estratozona_nombre = 'Zona desconocida'
        else:
            print(f'betaraster-> cod_estratozona_txt ({type(cod_estratozona_txt)}), {cod_estratozona_txt}')
            cod_estratozona_txt_sinExtras = '-'
            cod_estratozona_nombre = 'Zona desconocida'

        if capa_MDL_encontrada and not cod_num_txt_modeloDL.startswith('no'):
            resultado_msg += f'\n    Zona:     {cod_estratozona_txt_sinExtras}'
            resultado_msg += f'\n                  {cod_estratozona_nombre}'
            if type(cod_estratozona_txt) == str and '&sinHoja' in cod_estratozona_txt:
                resultado_msg += f'\n                  Variante sin hoja del modelo'
            resultado_msg += f'\n    Modelo:  {cod_modelo_txt}'
        else:
            if not capa_MDL_encontrada:
                if capa_nombre_MDL == 'modelo_Hdom_CyL':
                    resultado_msg += f'\n\nLa altura dominante lidar es una métrica lidar\nNo es una variable estimada por regresión\nNo tiene modelo ni necesita zonas o estratos.'
                else:
                    resultado_msg += f'\n\nCapa con el modelo de la variable {capa_nombre_MDL}\nno disponible en el proyecto.'
            elif cod_num_txt_modeloDL == 'noValida' or cod_num_txt_modeloDL == 'noNumero':
                resultado_msg += f'\n\nCapa con el modelo de la variable {capa_nombre_MDL}\nha dado error. Revisar la capa.'
        return resultado_msg

    def obtener_volumen(
            self,
            punto_click,
            boton_click,
            tipo_consulta='',
            rodal_feat=None,
            # layer_rodales=None,
            # raster_dataset_volumen=None,
            # raster_array=None,
    ):
        self.boton_click = boton_click
        self.punto_click = punto_click

        # print(f'betaraster-> obtener_volumen-> punto_click ({type(self.punto_click)}): {self.punto_click}')  #  (<class 'qgis._core.QgsPointXY'>): <QgsPointXY: POINT(260113 4739732)>
        # print(f'betaraster-> obtener_volumen-> boton_click ({type(self.boton_click)}): {self.boton_click}')  #  (<class 'PyQt5.QtCore.Qt.MouseButton'>): 1
        # print(f'betaraster-> obtener_volumen-> tipo_consulta: {tipo_consulta}')

        if boton_click == Qt.LeftButton:
            print(f'betaraster-> Has hecho click con el botón izdo en (b): {self.punto_click}')
            capa_activa_es_raster = False

            if tipo_consulta == 'parcela':
                # Elimino el círculo después de hacer clic
                self.tool_parcela.rubber_band.reset(QgsWkbTypes.PolygonGeometry)
            elif tipo_consulta == 'rodal':
                # Crear un QTimer para eliminar el resaltado después de cierto tiempo
                timer = QTimer()
                timer.setSingleShot(True)
                timer.timeout.connect(lambda: self.tool_rodal.rubberBand.reset(QgsWkbTypes.PolygonGeometry))
                timer.start(3000)  # 1000 ms = 1 segundo
# ç
            # Busco la capa ráster que tiene los volúmemens para:
            #  Consultar rodal -> Siempre se consulta volumen xq la capa activa es la de rodales/lotes/polígonos
            #  Consultar parcela -> Se consulta la capa raster activa salvo que no sea raster en cuy caso se busca la de volúmenes
            (
                layer_raster_VCC_find_bool,
                layer_raster_VCC_name_txt,
                layer_raster_VCC_selec_layer,
            ) = self.buscar_raster_volumenes()
            print(f'betaraster-> layer_raster_VCC_selec_layer ({type(layer_raster_VCC_selec_layer)}: {layer_raster_VCC_selec_layer})')

            if tipo_consulta == 'parcela':
                # Usar la capa activa si es raster; en caso contrario, usar la capa de volúmenes
                (
                    self.layer_raster_XXX_find_bool,
                    self.layer_raster_XXX_name_txt,
                    self.layer_raster_XXX_selec_layer,
                ) = self.buscar_raster_activo(
                    layer_raster_VCC_find_bool,
                    layer_raster_VCC_name_txt,
                    layer_raster_VCC_selec_layer,
                )
                if not self.layer_raster_XXX_find_bool:
                    return False
                # En realidad cuando conulto parcel, solo necesito el crs
                # para darselo a mostrar_resultado<> que lo usa cuando
                # se consulta u rodal y se aportan datos para mandar por mail
                self.layer_crs = self.layer_raster_XXX_selec_layer.crs()
                print(f'betaraster-> self.layer_crs ({type(self.layer_crs)}): {self.layer_crs}')
            else:
                self.layer_raster_XXX_find_bool = layer_raster_VCC_find_bool
                self.layer_raster_XXX_name_txt = layer_raster_VCC_name_txt
                self.layer_raster_XXX_selec_layer = layer_raster_VCC_selec_layer
            print(f'betaraster-> self.layer_raster_XXX_selec_layer ({type(self.layer_raster_XXX_selec_layer)}: {self.layer_raster_XXX_selec_layer.name()})')

            usar_mfe_raster = True
            if self.buscar_esp_mfe:
                (
                    (capa_mfe_sp1_encontrada, cod_num_mfe_sp1, cod_2L_sp1, nombre_sp1, dasolidar_sp1, cod_num_txt_asimilada_sp1),
                    (capa_mfe_sp2_encontrada, cod_num_mfe_sp2, cod_2L_sp2, nombre_sp2, dasolidar_sp2, cod_num_txt_asimilada_sp2),
                    (valor_raster_float, valor_raster_ok),
                    (capa_MFE_encontrada, cod_num_especie, cod_2L_especie, nombre_especie),
                ) = identifica_especies_mfe(self.punto_click, usar_mfe_raster=usar_mfe_raster)
                if usar_mfe_raster:
                    capa_MFE_encontrada = capa_mfe_sp1_encontrada
                    cod_num_especie = cod_num_mfe_sp1
                    cod_2L_especie = cod_2L_sp1
                    nombre_especie = nombre_sp1
                cod_num_asimilada_sp_ = int(cod_num_txt_asimilada_sp1)
            else:
                # Fuente: capa vectorial:
                capa_MFE_encontrada = False
                cod_num_especie = 0
                cod_2L_especie = 'Xx'
                nombre_especie = 'Especie desconocida'
                # Fuente: capas raster:
                (capa_mfe_sp1_encontrada, cod_num_mfe_sp1, cod_2L_sp1, nombre_sp1, dasolidar_sp1, cod_num_txt_asimilada_sp1) = (False, 0, 'Xx', 'Especie desconocida', 'NO', 0)
                (capa_mfe_sp2_encontrada, cod_num_mfe_sp2, cod_2L_sp2, nombre_sp2, dasolidar_sp2, cod_num_txt_asimilada_sp2) = (False, 0, 'Xx', 'Especie desconocida', 'NO', 0)
                (valor_raster_float, valor_raster_ok) = (0.0, False)
                cod_num_asimilada_sp_ = int(cod_num_txt_asimilada_sp1)

            if self.buscar_modelo_regresion:
                (
                    capa_MDL_encontrada,
                    capa_nombre_MDL,
                    cod_num_txt_modeloDL,
                    cod_modelo_txt,
                    cod_variable_explicada,
                    mod_num_asimilada_sp_,
                    cod_estratozona_txt,
                ) = self.identifica_modelo()
            else:
                capa_MDL_encontrada = False
                capa_nombre_MDL = ''
                cod_num_txt_modeloDL = ''
                cod_modelo_txt = ''
                cod_variable_explicada = 'Xx'
                mod_num_asimilada_sp_ = 0
                cod_estratozona_txt = 'x'

            if self.buscar_modelo_regresion:
                _od_num_asimilada_sp_ = mod_num_asimilada_sp_
            else:
                _od_num_asimilada_sp_ = cod_num_asimilada_sp_

            x_consulta = self.punto_click.x()
            y_consulta = self.punto_click.y()
            if tipo_consulta == 'parcela':
                valor_medio, num_pixeles, dict_spp_mfe_1, dict_spp_mfe_2 = calcular_valor_medio_parcela_rodal(
                    self.layer_raster_XXX_selec_layer,
                    x_consulta,
                    y_consulta,
                    radio_parcela=self.radio_parcela,
                    parcela_circular=self.parcela_circular,
                    buscar_esp_mfe=self.buscar_esp_mfe,
                    usar_mfe_raster=usar_mfe_raster,
                )
            elif tipo_consulta == 'rodal':
                valor_medio, num_pixeles = 0, 0
                rodal_geom = rodal_feat.geometry()
                dest_crs = QgsCoordinateReferenceSystem('EPSG:25830')
                if dest_crs == self.layer_crs:
                    rodal_hectareas = rodal_geom.area() / 10000
                else:
                    transformer = QgsCoordinateTransform(self.layer_crs, dest_crs, QgsProject.instance())
                    rodal_geom_reprojected = rodal_geom.clone()
                    rodal_geom_reprojected.transform(transformer)
                    rodal_hectareas = rodal_geom_reprojected.area() / 10000
                print(f'betaraster-> Superficie del rodal: {rodal_hectareas:0.2f} ha')
                if rodal_hectareas > 500:
                    mensaje('Calculando volumen del rodal...', mi_duration=10)

                valor_medio, num_pixeles, dict_spp_mfe_1, dict_spp_mfe_2 = calcular_valor_medio_parcela_rodal(
                    self.layer_raster_XXX_selec_layer,
                    x_consulta,
                    y_consulta,
                    # radio_parcela=self.radio_parcela,
                    # parcela_circular=self.parcela_circular,
                    rodal_consulta=True,
                    rodal_geom=rodal_geom,
                    buscar_esp_mfe=self.buscar_esp_mfe,
                    usar_mfe_raster=usar_mfe_raster,
                )
            else:
                print(f'betaraster-> Revisar este error')

            unidad_dasolidar = ''
            if isinstance(valor_medio, (int, float)):
                if (
                    self.layer_raster_XXX_name_txt.upper().startswith('VOL')
                    or self.layer_raster_XXX_name_txt.upper().startswith('VCC')
                    or (
                        'VOLUMEN' in self.layer_raster_XXX_name_txt.upper()
                        and not self.layer_raster_XXX_name_txt.upper().startswith('IAVC')
                        and not self.layer_raster_XXX_name_txt.upper().startswith('CRE')
                        and not 'CRECIM' in self.layer_raster_XXX_name_txt.upper()
                    )
                ):
                    valor_medio = int(round(valor_medio))
                    unidad_dasolidar = 'm3/ha'
                elif (
                    self.layer_raster_XXX_name_txt.upper().startswith('BA')
                    or self.layer_raster_XXX_name_txt.upper().startswith('BIO')
                    or 'BIOMASA' in self.layer_raster_XXX_name_txt.upper()
                ):
                    valor_medio = int(round(valor_medio))
                    unidad_dasolidar = 't/ha'
                elif (
                    self.layer_raster_XXX_name_txt.upper().startswith('ALT')
                    or 'ALTURA' in self.layer_raster_XXX_name_txt.upper()
                ):
                    valor_medio = round(valor_medio, 1)
                    unidad_dasolidar = 'm'
                elif (
                    self.layer_raster_XXX_name_txt.upper().startswith('COB')
                    or 'COBERTURA' in self.layer_raster_XXX_name_txt.upper()
                    or 'CUBIERTA' in self.layer_raster_XXX_name_txt.upper()
                    or 'FRACCION' in self.layer_raster_XXX_name_txt.upper()
                ):
                    valor_medio = int(round(valor_medio))
                    unidad_dasolidar = '%'
                elif (
                    self.layer_raster_XXX_name_txt.upper().startswith('AB')
                    or 'BASIMETRICA' in self.layer_raster_XXX_name_txt.upper()
                ):
                    valor_medio = round(valor_medio, 1)
                    unidad_dasolidar = 'm2/ha'
                elif (
                    self.layer_raster_XXX_name_txt.upper().startswith('IAVC')
                    or self.layer_raster_XXX_name_txt.upper().startswith('CRE')
                    or 'CRECIM' in self.layer_raster_XXX_name_txt.upper()
                ):
                    valor_medio = round(valor_medio, 2)
                    unidad_dasolidar = 'm3/ha.año'
                else:
                    valor_medio = round(valor_medio, 2)
                    unidad_dasolidar = ''
            else:
                valor_medio = -1

            # if math.isnan(valor_medio):
            if np.isnan(valor_medio):
                iface.messageBar().pushMessage(
                    title='dasoraster',
                    text=f'La capa activa no se puede consultar. Activa una capa ráster para poder hacer consultas.',
                    # showMore=f'',
                    duration=30,
                    level=Qgis.Warning,
                )
            elif valor_medio == -1:
                QMessageBox.information(
                    self.iface.mainWindow(),
                    'Consulta dasolidar: parcela',
                    f'Parcela de r={self.radio_parcela} m\nCentro parcela: {x_consulta:0.1f}, {y_consulta:0.1f}\nValor en capa {self.layer_raster_XXX_name_txt}: No hay pixeles con valores válidos'
                )
            else:
                if tipo_consulta == 'parcela':
                    rodal_hectareas = 0
                    resultado_msg = f'Parcela de radio: {self.radio_parcela} m'
                    resultado_msg += f'\nCentro parcela: {x_consulta:0.1f}, {y_consulta:0.1f}'
                    # if self.buscar_esp_mfe or self.buscar_modelo_regresion:
                    #     resultado_msg += f'\n\nInformación del punto clickeado:'
                    if self.buscar_esp_mfe:
                        resultado_msg = self.mostrar_especie(
                            tipo_consulta,
                            resultado_msg,
                            capa_MFE_encontrada,
                            cod_num_especie,
                            cod_2L_especie,
                            nombre_especie,
                            cod_num_asimilada_sp_,
                            dict_spp_mfe_1=dict_spp_mfe_1,
                            dict_spp_mfe_2=dict_spp_mfe_2,
                        )
                    if self.buscar_modelo_regresion:
                        resultado_msg = self.mostrar_modelo(
                            resultado_msg,
                            capa_MFE_encontrada,
                            cod_num_especie,
                            mod_num_asimilada_sp_,
                            capa_MDL_encontrada,
                            capa_nombre_MDL,
                            cod_num_txt_modeloDL,
                            cod_estratozona_txt,
                            cod_modelo_txt,
                        )
                    if unidad_dasolidar == 'm3/ha':
                        resultado_msg += f'\n\nVolumen medio: {valor_medio} {unidad_dasolidar}'
                    else:
                        resultado_msg += f'\n\n{self.layer_raster_XXX_name_txt}: {valor_medio} {unidad_dasolidar}'
                elif tipo_consulta == 'rodal':
                    rodal_fid = rodal_feat.id()
                    resultado_msg = ''
                    # resultado_msg += f'ATENCION: esta herramienta está en desarrollo.'
                    # resultado_msg += f'\nEstá pendiente revisar si se consultan los píxeles que corresponden.'
                    # resultado_msg += f'\nCuando esté revisado se quitará este mensaje y los valores nulos.'
                    # resultado_msg += f'\n\n'

                    resultado_msg += f'Información del polígono (rodal o lote):'
                    resultado_msg += f'\n    Id: {rodal_fid}'
                    resultado_msg += f'\n    Superficie: {rodal_hectareas:0.2f} ha'
                    # if self.buscar_esp_mfe or self.buscar_modelo_regresion:
                    #     resultado_msg += f'\n\nInformación del punto clickeado:'
                    if self.buscar_esp_mfe:
                        resultado_msg = self.mostrar_especie(
                            tipo_consulta,
                            resultado_msg,
                            capa_MFE_encontrada,
                            cod_num_especie,
                            cod_2L_especie,
                            nombre_especie,
                            cod_num_asimilada_sp_,
                            dict_spp_mfe_1=dict_spp_mfe_1,
                            dict_spp_mfe_2=dict_spp_mfe_2,
                        )
                    if self.buscar_modelo_regresion:
                        resultado_msg = self.mostrar_modelo(
                            resultado_msg,
                            capa_MFE_encontrada,
                            cod_num_especie,
                            mod_num_asimilada_sp_,
                            capa_MDL_encontrada,
                            capa_nombre_MDL,
                            cod_num_txt_modeloDL,
                            cod_estratozona_txt,
                            cod_modelo_txt,
                        )
                    if unidad_dasolidar == 'm3/ha':
                        resultado_msg += f'\n\nVolumen de madera:'
                        valor_total = int(round(valor_medio * rodal_hectareas))
                        resultado_msg += f'\n    Volumen medio:  {str(valor_medio):>8} {unidad_dasolidar}'
                        resultado_msg += f'\n    Volumen total: {str(valor_total):>8} m3'
                    else:
                        resultado_msg += f'\n\nValor medio de la variable:'
                        resultado_msg += f'\n    {self.layer_raster_XXX_name_txt}: {valor_medio} {unidad_dasolidar}'

                    if usuario_alfa:
                        resultado_msg += f'\n\nNúmero de pixeles: {num_pixeles}'
                else:
                    print(f'betaraster-> Atención: revisar código')

                print(f'betaraster-> Se van a mostrar los resultados de la consulta')
                mostrar_resultado(
                    tipo_consulta,
                    resultado_msg,
                    x_consulta,
                    y_consulta,
                    self.parcela_circular,
                    self.radio_parcela,
                    rodal_hectareas,
                    self.layer_raster_XXX_name_txt,
                    valor_medio,
                    unidad_dasolidar,
                    num_pixeles,
                    cod_2L_especie,
                    cod_modelo_txt,
                    cod_variable_explicada,
                    _od_num_asimilada_sp_,
                    cod_estratozona_txt,
                    rodal_feat=rodal_feat,
                    layer_crs=self.layer_crs,
                )
            if tipo_consulta == 'parcela':
                if self.consulta_multiple:
                    # self.action2.setChecked(True)
                    if self.action2.isChecked():
                        print(f'betaraster-> Se lanza de nuevo la herramienta (b)')
                        self.consultar_parcela()
                    print(f'betaraster-> self.action2.isChecked() 5a: {self.action2.isChecked()}')
                else:
                    print(f'betaraster-> Elimino trazado de la parcela (b)')
                    # Elimino el círculo después de hacer clic
                    self.action2.setChecked(False)
                    self.canvas.unsetMapTool(self.tool_parcela)
                    print(f'betaraster-> self.action2.isChecked() 5b: {self.action2.isChecked()}')

    def mostrar_dialogo_compilado(self):
        if self.first_start_consulta_rodal == True:
            self.first_start_consulta_rodal = False
            self.dlg_consulta_rodal = DasorasterDialog_consulta_rodal()
        try:
            # show the dialog
            self.dlg_consulta_rodal.show()
            # Run the dialog event loop
            result = self.dlg_consulta_rodal.exec_()
        except Exception as mi_error:
            print(f'betaraster-> Error:  {mi_error}')

    def explorar_ldata(self):
        print(f'betaraster-> explorar_ldata')
        ldata_path = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$'
        if os.path.exists(ldata_path):
            print(f'betaraster-> Directorio disponible ok: {ldata_path}')
        else:
            print(f'betaraster-> Directorio no accesible: {ldata_path}')
            iface.messageBar().pushMessage(
                title='dasoraster',
                text=f'No hay acceso a la unidad de red {ldata_path}.',
                showMore=f'Esto puede ser debido a:\n  1. El usuario {usuario_actual} no está dado de alta en la lista de usuarios del proyecto dasolidar\n  2. Se está trabajando fuera de la intranet de la Junta de Castilla y León.\n\nEste recurso solo está disponible para los usuarios del proyecto dasolidar con acceso a la intranet de la Junta de Castilla y León',
                duration=30,
                level=Qgis.Warning,
            )
            return
        rpta_ok = subprocess.Popen(f'explorer "{ldata_path}"')
        # print(f'betaraster-> Rpta de explorar_ldata: {type(rpta_ok)}')  #  <class 'subprocess.Popen'>
        print(f'betaraster-> Directorio explorado: {rpta_ok.args}')
        print(f'betaraster-> Respuesta: {rpta_ok.returncode}')

    def guia_rapida_dasolidar(self):
        global config_class
        print(f'betaraster-> Se va a instanciar VentanaBienvenidaPrimerosPasos desde mostrar_ventana_bienvenida_primeros_pasos')
        dialog = VentanaBienvenidaGuiaRapida()
        if dialog.ok:
            rpta_ok = dialog.exec_()
        # Esto no lo uso. La opción de mostrar ventana de bienvenida la dejo para el script de arranque
        if rpta_ok == QDialog.Accepted and False:
            if dialog.mostrar_checkbox.isChecked():
                print(f'betaraster-> Seguir mostrando la ventana de bienvenida')
                config_class.dl_mostrar_ventana_bienvenida = True
                config_class.dl_mostrar_message_bienvenida = True
            else:
                print(f'betaraster-> No mostrar la ventana de bienvenida')
                config_class.dl_mostrar_ventana_bienvenida = False
                config_class.dl_mostrar_message_bienvenida = True
            mi_config.setValue('dasolidar/mostrar_ventana_bienvenida', config_class.dl_mostrar_ventana_bienvenida)
            mi_config.setValue('dasolidar/mostrar_message_bienvenida', config_class.dl_mostrar_message_bienvenida)

    def manual_dasolidar(self):
        ruta_manual_red = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\doc\ayudaDasolidar'
        ruta_manual_local = os.path.join(PLUGIN_DIR, 'resources/docs')
        rutas_manual = [ruta_manual_red, ruta_manual_local]
        for ruta_manual in rutas_manual:
            manual_dasolidar_pdf_filepath = os.path.join(ruta_manual, 'manualDasoLidar.pdf')
            if os.path.exists(manual_dasolidar_pdf_filepath):
                print(f'betaraster-> manual_dasolidar_pdf_filepath_ok: {manual_dasolidar_pdf_filepath}')
                if self.lector_pdf_windows:
                    if platform.system() == 'Windows':
                        os.startfile(manual_dasolidar_pdf_filepath)
                else:
                    try:
                        from PyQt5.QtWebEngineWidgets import QWebEngineView
                        print(f'betaraster-> PyQtWebEngine está instalado.')
                    except ImportError:
                        print(f'betaraster-> PyQtWebEngine no está instalado.')
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text='Solo está disponible la opción de lector pdf predeterminado de Windows. No necesitas hacer nada, ya hemos activado por tí esa opción en [settingd] -> Vuelve a intentarlo.',
                            showMore=f'PyQtWebEngine no está instalado: para mostrar el manual dasolidar sin usar la app predeterminada de Windows a los pdf se requiere el paquete PyQtWebEngine.',
                            duration=30,
                            level=Qgis.Warning,
                        )
                        self.lector_pdf_windows = True
                        QSettings().setValue('dasoraster/lector_pdf_windows', self.lector_pdf_windows)
                        # !pip install PyQtWebEngine
                        return
                    app = QApplication(sys.argv)
                    viewer = PDFViewer(manual_dasolidar_pdf_filepath)
                    viewer.show()
                    sys.exit(app.exec_())
                break
            else:
                print(f'betaraster-> Fichero no disponible: {manual_dasolidar_pdf_filepath}')
        if not os.path.exists(manual_dasolidar_pdf_filepath):
            iface.messageBar().pushMessage(
                title='dasoraster',
                text='Manual de consulta dasolidar no disponible. Puede que no estés trabajando dentro de la intranet de la JCyL o no estés dado de alta en el proyecto dasolidar',
                duration=20,
                level=Qgis.Warning,
            )
            self.ok = False
            return

    def dasolidar_IA(self):
        try:
            dialog = VentanaAsistente(
                parent=None,
                botones_disponibles='sugerencia_consultas_ejecucion',
            )
            rpta_ok = dialog.exec_()
        except Exception as e:
            print(f'betaraster-> Ocurrió un error al mostrar la ventana 1: {e}')
        # Esto siguiente sobra; lo dejo just in case
        print(f'betaraster-> Rpta de VentanaAsistente: {rpta_ok}')
        if rpta_ok == QDialog.Accepted:
            consulta_usuario = dialog.get_text()
            boton_pulsado = dialog.button_pressed
            print(f'betaraster-> Texto de consulta o petición:', consulta_usuario)
            print(f'betaraster-> Botón pulsado:', boton_pulsado)
        else:
            print(f'betaraster-> Consulta o petición canceladas')

    def dasoraster_settings(self):
        dict_settings = {}
        dict_settings['radio_parcela'] = self.radio_parcela
        dict_settings['parcela_circular'] = self.parcela_circular
        dict_settings['consulta_multiple'] = self.consulta_multiple
        dict_settings['buscar_modelo_regresion'] = self.buscar_modelo_regresion
        dict_settings['buscar_esp_mfe'] = self.buscar_esp_mfe
        print(f'betaraster-> self.buscar_esp_mfe 0: {self.buscar_esp_mfe}')
        dict_settings['autocarga_lasfiles'] = self.autocarga_lasfiles
        dict_settings['autocarga_escala_maxima'] = self.autocarga_escala_maxima
        # dict_settings['autocarga_mostrar_lasfiles_en_leyenda'] = self.autocarga_mostrar_lasfiles_en_leyenda
        dict_settings['lector_pdf_windows'] = self.lector_pdf_windows

        dialog = SettingsDialog(dict_settings)
        if dialog.exec_():
            # Actualizo los valores de la clase con los nuevos valores
            settings = QSettings()
            self.radio_parcela = settings.value('dasoraster/radio_parcela', type=float)
            self.parcela_circular = settings.value('dasoraster/parcela_circular', type=bool)
            self.consulta_multiple = settings.value('dasoraster/consulta_multiple', type=bool)
            self.buscar_modelo_regresion = settings.value('dasoraster/buscar_modelo_regresion', type=bool)
            self.buscar_esp_mfe = settings.value('dasoraster/buscar_esp_mfe', type=bool)
            print(f'betaraster-> self.buscar_esp_mfe 1: {self.buscar_esp_mfe}')
            self.autocarga_lasfiles = settings.value('dasoraster/autocarga_lasfiles', type=bool)  #  Se inicia siempre en False
            self.autocarga_escala_maxima = settings.value('dasoraster/autocarga_escala_maxima', type=int)
            # self.autocarga_mostrar_lasfiles_en_leyenda = settings.value('dasoraster/autocarga_mostrar_lasfiles_en_leyenda', type=bool)
            self.lector_pdf_windows = settings.value('dasoraster/lector_pdf_windows', type=bool)  #  Se inicia siempre en True

        # La autocarga de lasfiles podría pasarlo a un botón en vez usar de una opción de settings,
        # pero por el momento prefiero dejarlo aquí más oculto. Si la autocarga es operativa, seguramente lo cambie.
        self.auto_lasfile()

    def auto_lasfile(self):
        if self.autocarga_lasfiles:
            if self.autoCargaLasFileObj is None:
                # Instancio la clase AutoCargaLasFile para que cargue lasfiles cuando se mueva el canvas
                # Se instancia con la propiedad active_auto_lasfile = True
                self.autoCargaLasFileObj = AutoCargaLasFile(
                    self.canvas,
                    autocarga_escala_maxima=self.autocarga_escala_maxima,
                    # autocarga_mostrar_lasfiles_en_leyenda=self.autocarga_mostrar_lasfiles_en_leyenda,
                )
                if not self.autoCargaLasFileObj.malla_disponible:
                    return
                # Al instanciarse AutoCargaLasFile se ejecuta self.actualizar_lasfiles()
                self.iface.messageBar().pushMessage(
                    f'Autocarga de lasFiles activado', duration=3, level=Qgis.Info
                )
            else:
                self.autoCargaLasFileObj.actualizar_lasfiles()
                self.autoCargaLasFileObj.active_auto_lasfile = True
                self.autoCargaLasFileObj.autocarga_escala_maxima = self.autocarga_escala_maxima
                # self.autoCargaLasFileObj.autocarga_mostrar_lasfiles_en_leyenda = self.autocarga_mostrar_lasfiles_en_leyenda
                self.iface.messageBar().pushMessage(
                    f'Autocarga de lasFiles re-activado', duration=3, level=Qgis.Info
                )
        else:
            if self.autoCargaLasFileObj:
                try:
                    # self.autoCargaLasFileObj.active_auto_lasfile = False
                    self.iface.messageBar().pushMessage(
                        f'Autocarga de lasFiles desactivado', duration=5, level=Qgis.Info
                    )
                    self.autoCargaLasFileObj.unload()
                    self.autoCargaLasFileObj = None
                except:
                    pass

    def dasoraster_extra(self):
        self.iface.messageBar().pushMessage(f'Botón disponible para nuevas utilidades', level=Qgis.Info)
        print(f'betaraster-> self.action_extra.isEnabled() 1: {self.action_extra.isEnabled()}')
        print(f'betaraster-> self.action_extra.isChecked() 1: {self.action_extra.isChecked()}')
        self.toggle_plugin()
        print(f'betaraster-> self.action_extra.isEnabled() 2: {self.action_extra.isEnabled()}')
        print(f'betaraster-> self.action_extra.isChecked() 2: {self.action_extra.isChecked()}')
        # QMessageBox.information(
        #     iface.mainWindow(),
        #     f'Fase beta dasolidar',
        #     f'Eres alfa tester'
        #     f'Gracias por tu colaboración'
        # )
        dialog = QDialog()
        dialog.setWindowTitle('dasolidar beta')
        label = QLabel(
            f'Eres alfa tester\n'\
            f'Gracias por tu colaboración'
        )
        label.setAlignment(Qt.AlignCenter)  # Centrar el texto
        layout = QVBoxLayout()
        layout.addWidget(label)
        button = QPushButton('Ok')
        button.clicked.connect(dialog.accept)  # Cerrar el diálogo al hacer clic
        layout.addWidget(button)
        dialog.setLayout(layout)
        dialog.exec_()


    def toggle_plugin(self):
        # print(f'betaraster-> toggle_plugin-> self.active_extra 1: {self.active_extra}')
        self.active_extra = not self.active_extra
        if self.active_extra:
            self.iface.messageBar().pushMessage('Botón extra activado', level=Qgis.Info)
        else:
            self.iface.messageBar().pushMessage('Botón extra desactivado', level=Qgis.Info)
        print(f'betaraster-> toggle_plugin-> self.active_extra 2: {self.active_extra}')


# ==============================================================================
class CustomMapTool(QgsMapToolEmitPoint):
    def __init__(self, canvas, radio_parcela, parcela_circular, consulta_multiple):
        super().__init__(canvas)
        self.canvas = canvas
        self.rubber_band = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rubber_band.setColor(QColor(255, 0, 0, 100))
        self.rubber_band.setWidth(1)
        self.setCursor()
        self.radio_parcela = radio_parcela
        self.parcela_circular = parcela_circular
        self.consulta_multiple = consulta_multiple

    def setCursor(self):
        pixmap = QPixmap(32, 32)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setPen(QPen(Qt.black, 2))
        painter.drawLine(16, 0, 16, 32)
        painter.drawLine(0, 16, 32, 16)
        painter.end()
        self.cursor = QCursor(pixmap)
        self.canvas.setCursor(self.cursor)

    def canvasMoveEvent(self, event):
        punto_move = self.toMapCoordinates(event.pos())
        self.rubber_band.reset(QgsWkbTypes.PolygonGeometry)
        if self.parcela_circular:
            self.draw_circle(punto_move)
        else:
            self.draw_square(punto_move)

    def draw_circle(self, punto_move):
        circle = QgsGeometry.fromPointXY(punto_move).buffer(self.radio_parcela, 50)
        self.rubber_band.setToGeometry(circle, QgsProject.instance().crs())
        # circle_item = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        # circle_item.setToGeometry(circle, QgsProject.instance().crs())
        # circle_item.setColor(QColor(255, 0, 0, 100))
        # circle_item.setWidth(1)

    def draw_square(self, punto_move):
        semi_lado = self.radio_parcela
        cuadrado_move = [
            QgsPointXY(punto_move.x() - semi_lado, punto_move.y() - semi_lado),
            QgsPointXY(punto_move.x() + semi_lado, punto_move.y() - semi_lado),
            QgsPointXY(punto_move.x() + semi_lado, punto_move.y() + semi_lado),
            QgsPointXY(punto_move.x() - semi_lado, punto_move.y() + semi_lado),
            QgsPointXY(punto_move.x() - semi_lado, punto_move.y() - semi_lado)  # Close the square
        ]
        square = QgsGeometry.fromPolygonXY([cuadrado_move])
        self.rubber_band.setToGeometry(square, QgsProject.instance().crs())

    def canvasReleaseEvent(self, event):
        punto_release = self.toMapCoordinates(event.pos())
        print(f'betaraster-> Has hecho click en (a): {punto_release}')
        if self.consulta_multiple:
            print(f'betaraster-> Se lanza de nuevo la herramienta')
            # self.consultar_parcela()
        else:
            print(f'betaraster-> Elimino trazado de la parcela')
            # Elimino el círculo después de hacer clic
            self.rubber_band.reset(QgsWkbTypes.PolygonGeometry)

# https://qgis.org/pyqgis/master/gui/QgsMapToolIdentifyFeature.html
# Clase: QgsMapToolIdentifyFeature
# Methods: setLayer
#     change the layer used by the map tool to identify
# Signals: featureIdentified
#     Emitted when a feature has been identified by its id.

# ==============================================================================
# class ConsultarRodalTool(QgsMapToolIdentifyFeature):
class ConsultarRodalTool(QgsMapToolEmitPoint):
    pointEmitted = pyqtSignal(object)

    def __init__(self, canvas):
        super().__init__(canvas)
        self.canvas = canvas
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rubberBand.setColor(Qt.red)
        self.rubberBand.setWidth(2)
        print(f'betaraster-> Instanciando ConsultarRodalTool')
        self.setCursor()

    def activate(self):
        self.canvas.setCursor(QCursor(Qt.CrossCursor))
        super().activate()

    def setCursor(self):
        pixmap = QPixmap(32, 32)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setPen(QPen(Qt.black, 2))
        painter.drawLine(16, 0, 16, 32)
        painter.drawLine(0, 16, 32, 16)
        painter.end()
        self.cursor = QCursor(pixmap)
        self.canvas.setCursor(self.cursor)

    def canvasReleaseEvent(self, event):
        punto_release = self.toMapCoordinates(event.pos())
        print(f'betaraster-> Se ha hecho click en (2) {punto_release}')
        self.pointEmitted.emit(punto_release)

    def canvasReleaseEvent_sin_uso(self, event):
        layer = self.canvas.currentLayer()
        if not isinstance(layer, QgsVectorLayer):
            print(f'betaraster-> La capa activa no es vectorial.')
            return
        print(f'betaraster-> Vector layer: {layer.name()}')

        punto_release = self.toMapCoordinates(event.pos())
        print(f'betaraster-> Se ha hecho click en (0) {punto_release}')

        # self.setLayer(layer)
        # features_identificadas = self.featureIdentified()
        # features_identificadas = self.identify(punto_release, [layer], QgsMapToolIdentify.TopDownStopAtFirst)
        # features_identificadas = self.identify(punto_release, [layer])
        # features_identificadas = self.identifyVectorLayer(layer, punto_release, QgsMapToolIdentifyFeature.LayerSelection)
        features_identificadas = self.identify(punto_release, [layer], QgsMapToolIdentifyFeature.LayerSelection)

        if not features_identificadas:
            print(f'betaraster-> No se encontró ningún polígono en el punto clicado.')
            return

        # Convertir el iterador a una lista para contar las características
        features_list = list(features_identificadas)
        # Contar el número de características
        num_features = len(features_list)
        print(f'betaraster-> Número de poligonos identificados-> {num_features}')

        # for feature in features_list:
        feature = features_list[0].mFeature
        self.rubberBand.setToGeometry(feature.geometry(), layer)

        # Obtener la capa raster VolumenMadera_m3_ha
        raster_layer = QgsProject.instance().mapLayersByName('VolumenMadera_m3_ha')[0]
        if not isinstance(raster_layer, QgsRasterLayer):
            print(f'betaraster-> No se encontró la capa raster VolumenMadera_m3_ha.')
            return

        print(f'betaraster-> Raster layer: {raster_layer.name()}')

        # Calcular el valor medio de los píxeles del ráster en el polígono
        stats = raster_layer.dataProvider().bandStatistics(1, QgsRasterBandStats.Mean, feature.geometry().boundingBox())
        mean_value = stats.mean
        print(f'betaraster-> El valor medio de los píxeles del ráster en el polígono es: {mean_value}')



# ==============================================================================
class SettingsDialog(QDialog):
    # def __init__(self, parent=None):
    def __init__(self, dict_settings, parent=None):
        super(SettingsDialog, self).__init__(parent)

        radio_parcela = dict_settings['radio_parcela']
        parcela_circular = dict_settings['parcela_circular']
        consulta_multiple = dict_settings['consulta_multiple']
        buscar_modelo_regresion = dict_settings['buscar_modelo_regresion']
        buscar_esp_mfe = dict_settings['buscar_esp_mfe']
        print(f'betaraster-> self.buscar_esp_mfe 2: {buscar_esp_mfe}')
        autocarga_lasfiles = dict_settings['autocarga_lasfiles']
        autocarga_escala_maxima = dict_settings['autocarga_escala_maxima']
        # autocarga_mostrar_lasfiles_en_leyenda = dict_settings['autocarga_mostrar_lasfiles_en_leyenda']
        lector_pdf_windows = dict_settings['lector_pdf_windows']
        self.setWindowTitle('Configuración')

        # Creo el layout
        layout = QVBoxLayout()
        form_layout = QFormLayout()

        # Creo los widgets
        self.radio_parcela_input = QLineEdit()
        self.radio_parcela_input.setText(str(radio_parcela))
        self.parcela_circular_input = QCheckBox()
        self.parcela_circular_input.setChecked(parcela_circular)
        self.consulta_multiple_input = QCheckBox()
        self.consulta_multiple_input.setChecked(consulta_multiple)
        self.buscar_modelo_regresion_input = QCheckBox()
        self.buscar_modelo_regresion_input.setChecked(buscar_modelo_regresion)
        self.buscar_esp_mfe_input = QCheckBox()
        self.buscar_esp_mfe_input.setChecked(buscar_esp_mfe)
        print(f'betaraster-> self.buscar_esp_mfe 3: {buscar_esp_mfe}')
        self.autocarga_lasfiles_input = QCheckBox()
        self.autocarga_escala_maxima_input = QLineEdit()
        # self.autocarga_mostrar_lasfiles_en_leyenda_input = QCheckBox()
        self.lector_pdf_windows_input = QCheckBox()
        if usuario_alfa:
            self.autocarga_lasfiles_input.setChecked(autocarga_lasfiles)
            self.autocarga_escala_maxima_input.setText(str(autocarga_escala_maxima))
            # self.autocarga_mostrar_lasfiles_en_leyenda_input.setChecked(autocarga_mostrar_lasfiles_en_leyenda)
            self.lector_pdf_windows_input.setChecked(lector_pdf_windows)
        else:
            self.autocarga_lasfiles_input.setChecked(False)
            self.autocarga_escala_maxima_input.setText(str(AUTOCARGA_ESCALA_MAXIMA_RECOMENDADA))
            # self.autocarga_mostrar_lasfiles_en_leyenda_input.setChecked(True)
            self.lector_pdf_windows_input.setChecked(True)
        if not usuario_alfa:
            self.autocarga_lasfiles_input.setEnabled(False)
            self.autocarga_escala_maxima_input.setEnabled(False)
            # self.autocarga_mostrar_lasfiles_en_leyenda_input.setEnabled(False)
            self.lector_pdf_windows_input.setEnabled(False)

        # Añado widgets al form layout
        form_layout.addRow('Radio parcela (m):', self.radio_parcela_input)
        form_layout.addRow('Parcela circular:', self.parcela_circular_input)
        form_layout.addRow('Consulta multi-parcela:', self.consulta_multiple_input)
        form_layout.addRow('Buscar modelo regresion Lidar:', self.buscar_modelo_regresion_input)
        form_layout.addRow('Buscar especie mfe25:', self.buscar_esp_mfe_input)
        form_layout.addRow('Activar carga automática lasfiles:', self.autocarga_lasfiles_input)
        form_layout.addRow('Escala maxima en carga automática:', self.autocarga_escala_maxima_input)
        # form_layout.addRow('Mostrar lasfiles en leyenda:', self.autocarga_mostrar_lasfiles_en_leyenda_input)
        form_layout.addRow('Usar lector pdf Windows:', self.lector_pdf_windows_input)
        if not usuario_alfa:
            label = QLabel('Carga automática de lasfiles en pruebas:\nSolo está disponible para alfa testers')
            form_layout.addRow(label)

        # Añado form layout al layout principal
        layout.addLayout(form_layout)

        # Creo botones
        self.ok_button = QPushButton('OK')
        self.cancel_button = QPushButton('Cancelar')

        # Añado botones al layout principal
        layout.addWidget(self.ok_button)
        layout.addWidget(self.cancel_button)

        # Conecto señales y slots
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        # Establezco el layout del diálogo
        self.setLayout(layout)

    def accept(self):
        # Guardo los valores en QSettings
        settings = QSettings()
        settings.setValue('dasoraster/radio_parcela', float(self.radio_parcela_input.text()))
        settings.setValue('dasoraster/parcela_circular', self.parcela_circular_input.isChecked())
        settings.setValue('dasoraster/consulta_multiple', self.consulta_multiple_input.isChecked())
        settings.setValue('dasoraster/buscar_modelo_regresion', self.buscar_modelo_regresion_input.isChecked())
        settings.setValue('dasoraster/buscar_esp_mfe', self.buscar_esp_mfe_input.isChecked())
        print(f'betaraster-> self.buscar_esp_mfe 4: {self.buscar_esp_mfe_input.isChecked()}')
        settings.setValue('dasoraster/autocarga_lasfiles', self.autocarga_lasfiles_input.isChecked())
        if int(self.autocarga_escala_maxima_input.text()) > AUTOCARGA_ESCALA_MAXIMA_PERMITIDA:
            self.autocarga_escala_maxima_input.setText(str(AUTOCARGA_ESCALA_MAXIMA_PERMITIDA))
            self.iface.messageBar().pushMessage(
                f'No se admiten escalas inferiores a 1:30000 (denominador superior {AUTOCARGA_ESCALA_MAXIMA_PERMITIDA}).',
                duration=5,
                level=Qgis.Info,
            )
        settings.setValue('dasoraster/autocarga_escala_maxima', int(self.autocarga_escala_maxima_input.text()))
        # settings.setValue('dasoraster/autocarga_mostrar_lasfiles_en_leyenda', self.autocarga_mostrar_lasfiles_en_leyenda_input.isChecked())
        settings.setValue('dasoraster/lector_pdf_windows', self.lector_pdf_windows_input.isChecked())
        # Llamo al método accept del QDialog
        super(SettingsDialog, self).accept()


# ==============================================================================

def foo():
    pass
