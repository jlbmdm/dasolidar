# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Dasoraster
                                 A QGIS plugin
 Herramientas para trabajar con rastes dasométricos
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-27
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Jose Bengoa
        email                : dasonoma@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
# import math
import platform
import subprocess
import numpy as np
from osgeo import gdal

# imports de plugin builder
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *

from .dasoraster_dialog import DasorasterDialog, DasorasterDialog_consulta_rodal

# Imports extras
from qgis.utils import iface
from qgis.core import (
    Qgis,
    # QgsApplication,
    # QgsMessageLog,
    QgsGeometry,
    QgsProject,
    QgsSettings,
    QgsVectorLayer,
    QgsRasterLayer,
    QgsRectangle,
    QgsPointXY,
    QgsWkbTypes,
    QgsPointCloudLayer,
    QgsLayerTreeGroup,
    QgsLayerTreeLayer,
    QgsSpatialIndex,
    QgsFeatureRequest,
    QgsCoordinateTransform,
    QgsCoordinateReferenceSystem,
    QgsMapLayer,
    QgsRasterBandStats,
)
from qgis.gui import (
    QgsMapToolEmitPoint,
    QgsRubberBand,
    QgsMapToolIdentifyFeature,
    QgsMapToolIdentify,
)

from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtGui import (
    QColor,
    QCursor,
    QPixmap,
    QPainter,
    QPen,
)
from qgis.PyQt.QtWidgets import (
    QTextBrowser,
    QLabel,
    QDialogButtonBox,
    QTextEdit,
    QAction,
    QMessageBox,
    # QFrame,
    # QSpacerItem,
    # QSizePolicy,
    # QGridLayout,
    # QDialog,
    # QVBoxLayout,
    # QLineEdit,
    # QCheckBox,
    # QPushButton,
    # QHBoxLayout,
    # QMainWindow,
    # QWidget,
)

from PyQt5.QtWidgets import (
    QApplication,
    QFormLayout,
    QDialog,
    QVBoxLayout,
    QLineEdit,
    QCheckBox,
    QPushButton,
    QMainWindow,
    QWidget,
)
from PyQt5.QtCore import (
    QUrl,
    pyqtSignal,
    QObject,
)


# imports para la descarga de lasFiles
# from qgis.core import QgsMessageLog
# from PyQt5.QtWidgets import QMessageBox
# from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox
# from qgis.PyQt.QtGui import QDesktopServices
# from qgis.PyQt.QtCore import QUrl
# from qgis.core import QgsFeature
# from PyQt5.QtWidgets import QInputDialog, QLineEdit


# ==============================================================================
plugin_dir = os.path.dirname(__file__)
try:
    mi_PYTHONPATH = os.environ['PYTHONPATH']
except:
    mi_PYTHONPATH = 'No disponible'
if plugin_dir not in sys.path:
    sys.path.append(plugin_dir)
print(f'PYTHONPATH: {mi_PYTHONPATH}')
print(f'sys.path: {sys.path}')

from dasoutil import calcular_valor_medio_parcela
from dasoutil import calcular_valor_medio_rodal
# from dasoutil import identificar_usuario
# usuario_actual = identificar_usuario()

try:
    # usuario_psutil = psutil.users()[0].name
    # usuario_psutil = psutil.users()
    usuario_env = ''
    usuario_profile = ''
    try:
        usuario_login = os.getlogin()
        print(f'Usuario_login ({type(usuario_login)}): {usuario_login}')
    except:
        usuario_login = None
        try:
            usuario_env = os.environ.get('USERNAME')
            print(f'Usuario_env ({type(usuario_env)}): {usuario_env}')
        except:
            usuario_env = None
            usuario_profile = os.path.expandvars("%userprofile%")[-8:].lower()
            print(f'Usuario_profile: {usuario_profile}')
    if isinstance(usuario_login, str) and len(usuario_login) == 8:
        usuario_actual = usuario_login.lower()
    elif isinstance(usuario_env, str) and len(usuario_env) == 8:
        usuario_actual = usuario_env.lower()
    elif isinstance(usuario_profile, str) and len(usuario_profile) == 8:
        usuario_actual = usuario_profile.lower()
    elif isinstance(usuario_login, str):
        usuario_actual = usuario_login.lower()
    elif isinstance(usuario_env, str):
        usuario_actual = usuario_env.lower()
    elif isinstance(usuario_profile, str):
        usuario_actual = usuario_profile.lower()
    else:
        usuario_actual = 'anonimo'
except:
    usuario_actual = 'anonimo'
print(f'usuario_actual: {usuario_actual}')


mi_config = QgsSettings()
class Configuracion():
    def __init__(self):
        self.dl_usuario = mi_config.value('dasolidar/usuario', 'anonimo')
        self.dl_usos  = mi_config.value('dasolidar/usos', 123)
        self.dl_mostrar_ventana_bienvenida = mi_config.value('dasolidar/mostrar_ventana_bienvenida', True)
        self.dl_mostrar_message_bienvenida = mi_config.value('dasolidar/mostrar_message_bienvenida', True)

class VentanaBienvenidaGuiaRapida(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.ok = True
        self.plugin_dir = os.path.dirname(__file__)

        self.setWindowTitle('Productos y herramientas Lidar para la gestión del medio natural')
        # self.setFixedSize(500, 200)  #  Dimensiones XX, YY
        # self.setGeometry(100, 100, 700, 400)
        self.resize(950, 700)  # Ancho y alto en píxeles
        self.center()

        # ======================================================================
        print('dasoraster-> Se va a mostrar la guia rápida')
        ruta_ayudas = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\doc\ayudaDasolidar'
        if os.path.exists(os.path.join(ruta_ayudas, 'GuiaDasoLidar.png')):
            intro_dasolidar_html_filename = 'dasolidar_intro.html'
        # elif os.path.exists(os.path.join(self.plugin_dir, 'GuiaDasoLidar.png')):
        #     intro_dasolidar_html_filename = 'dasolidar_intro_local.html'
        else:
            iface.messageBar().pushMessage(
                title='dasoraster',
                text='Guia rápida no disponible.',
                duration=20,
                level=Qgis.Warning,
            )
            self.ok = False
            return

        intro_dasolidar_html_filepath = os.path.join(ruta_ayudas, intro_dasolidar_html_filename)
        intro_dasolidar_html_obj = open(intro_dasolidar_html_filepath)
        intro_dasolidar_html_read = intro_dasolidar_html_obj.read()
        print(f'Ruta de la guia rápida: {intro_dasolidar_html_filepath}')

        # Layout horizontal para el texto
        texto_layout = QVBoxLayout()
        usar_html = True
        self.mi_texto = QTextBrowser()
        self.mi_texto.setHtml(intro_dasolidar_html_read)
        texto_layout.addWidget(self.mi_texto)
        # intro_dasolidar_html_obj.close()
        # Establezco el layout principal
        self.setLayout(texto_layout)
        # Ajusto el scroll para mostrar la parte superior
        self.mi_texto.verticalScrollBar().setValue(0)

    def center(self):
        qr = self.frameGeometry()
        cp = self.screen().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())


class VentanaAsistente(QDialog):
    def __init__(self, parent=None, botones_disponibles='consulta_diferida_sugerencia'):
        super().__init__(parent)
        self.iface = iface

        if botones_disponibles == 'consulta_diferida':
            self.setWindowTitle('Disponible próximamente: aquí podrás escribir consultas.')
        elif botones_disponibles.startswith('consulta_diferida_sugerencia'):
            self.setWindowTitle('Disponible próximamente: aquí podrás escribir consultas y sugerencias.')
        elif botones_disponibles == 'consulta_ejecucion':
            self.setWindowTitle('Disponible próximamente: aquí podrás escribir una consulta o pedir que se ejecute una acción')
        else:
            self.setWindowTitle('Disponible próximamente: aquí podrás escribir consultas.')
        # self.setFixedSize(500, 200)  #  Dimensiones XX, YY
        # self.setGeometry(100, 100, 700, 400)
        self.resize(600, 200)  #  Ancho y alto en píxeles
        self.center()

        # ======================================================================
        # Layout horizontal para el texto
        self.texto_layout = QVBoxLayout()
        # Mensaje de texto
        self.mi_texto = QLabel('Escribe tu consulta o petición:')
        self.mi_texto.setAlignment(Qt.AlignLeft)
        self.texto_layout.addWidget(self.mi_texto)

        # # Ventana de texto con tamaño fijo
        # self.text_input = QLineEdit(self)
        self.text_input = QTextEdit(self)
        self.text_input.setFixedSize(550, 100)  # Establece el tamaño (ancho, alto) en píxeles
        self.texto_layout.addWidget(self.text_input)

        # ======================================================================
        # Botones de Consulta, Acción y Cancelar
        self.buttonBox = QDialogButtonBox()
        # self.send_button = self.buttonBox.addButton('Enviar', QDialogButtonBox.AcceptRole)

        # ======================================================================
        if botones_disponibles == 'consulta_diferida':
            self.consultaD_button = self.buttonBox.addButton('Enviar consulta', QDialogButtonBox.AcceptRole)
            self.consultaD_button.clicked.connect(
                lambda event: self.lanzar_consulta_sugerencia(
                    mi_evento=event,
                    tipo_consulta='diferida',
                )
            )
        elif botones_disponibles.startswith('consulta_diferida_sugerencia'):
            self.sugerencia_button = self.buttonBox.addButton('Enviar sugerencia', QDialogButtonBox.AcceptRole)
            self.sugerencia_button.clicked.connect(
                lambda event: self.lanzar_consulta_sugerencia(
                    mi_evento=event,
                    tipo_consulta='sugerencia',
                )
            )
            if botones_disponibles.startswith('consulta_diferida_sugerencia_inmediata'):
                self.consultaD_button = self.buttonBox.addButton('Enviar consulta para rpta diferida', QDialogButtonBox.AcceptRole)
                self.consultaD_button.clicked.connect(
                    lambda event: self.lanzar_consulta_sugerencia(
                        mi_evento=event,
                        tipo_consulta='diferida',
                    )
                )
                self.consultaI_button = self.buttonBox.addButton('Enviar consulta para rpta inmediata', QDialogButtonBox.AcceptRole)
                self.consultaI_button.clicked.connect(
                    lambda event: self.lanzar_consulta_sugerencia(
                        mi_evento=event,
                        tipo_consulta='inmediata',
                    )
                )
            else:
                self.consultaD_button = self.buttonBox.addButton('Enviar consulta', QDialogButtonBox.AcceptRole)
                self.consultaD_button.clicked.connect(
                    lambda event: self.lanzar_consulta_sugerencia(
                        mi_evento=event,
                        tipo_consulta='diferida',
                    )
                )
        elif botones_disponibles == 'consulta_ejecucion':
            self.sugerencia_button = self.buttonBox.addButton('Enviar sugerencia', QDialogButtonBox.AcceptRole)
            self.consultaD_button = self.buttonBox.addButton('Enviar consulta para rpta diferida', QDialogButtonBox.AcceptRole)
            self.consultaI_button = self.buttonBox.addButton('Enviar consulta para rpta inmediata', QDialogButtonBox.AcceptRole)
            self.accion_button = self.buttonBox.addButton('Ejecutar acción', QDialogButtonBox.AcceptRole)
            self.sugerencia_button.clicked.connect(
                lambda event: self.lanzar_consulta_sugerencia(
                    mi_evento=event,
                    tipo_consulta='sugerencia',
                )
            )
            self.consultaD_button.clicked.connect(
                lambda event: self.lanzar_consulta_sugerencia(
                    mi_evento=event,
                    tipo_consulta='diferida',
                )
            )
            self.consultaI_button.clicked.connect(
                lambda event: self.lanzar_consulta_sugerencia(
                    mi_evento=event,
                    tipo_consulta='inmediata',
                )
            )
            self.accion_button.clicked.connect(self.lanzar_accion)
        else:
            self.consultaD_button = self.buttonBox.addButton('Enviar consulta', QDialogButtonBox.AcceptRole)
            self.consultaD_button.clicked.connect(
                lambda event: self.lanzar_consulta_sugerencia(
                    mi_evento=event,
                    tipo_consulta='diferida',
                )
            )
        self.cancel_button = self.buttonBox.addButton(QDialogButtonBox.Cancel)
        self.cancel_button.clicked.connect(self.reject)
        # ======================================================================

        # ======================================================================
        # Checkbox por si pido autorización para guardar la conaulta o petición en la base de datos
        self.checkbox = QCheckBox('Guardar consulta o petición.')
        self.checkbox.setChecked(True)
        self.texto_layout.addWidget(self.checkbox)
        # ======================================================================

        # Añadir el layout de botones al layout principal
        # self.texto_layout.addLayout(botones_layout)
        self.texto_layout.addWidget(self.buttonBox)

        # Establecer el layout principal
        self.setLayout(self.texto_layout)

    def mensaje(self, mi_text='', mi_title='dasoraster', mi_showMore=None, mi_duration=15, mi_level=Qgis.Info):
        if mi_showMore is None or type(mi_showMore) != str:
            self.iface.messageBar().pushMessage(
                title=mi_title,
                text=mi_text,
                duration=mi_duration,
                level=mi_level,
            )
        else:
            self.iface.messageBar().pushMessage(
                title=mi_title,
                text=mi_text,
                showMore=mi_showMore,
                duration=mi_duration,
                level=mi_level,
            )

    def center(self):
        qr = self.frameGeometry()
        cp = self.screen().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())

    def get_text(self):
        return self.text_input.toPlainText()

    def lanzar_consulta_sugerencia(
            self,
            mi_evento=None,
            mi_boton=None,
            tipo_consulta='diferida'
        ):
        print(f'---> lanzar_consulta_sugerencia 00-> tipo_consulta {tipo_consulta}')
        self.button_pressed = f'consulta_{tipo_consulta}'
        self.accept()
        print(f'Botón presionado: {self.button_pressed}. Texto introducido: {self.text_input.toPlainText()}')
        QMessageBox.information(
            iface.mainWindow(),
            f'Consulta dasolidar <{tipo_consulta}>',
            f'Esta utilidad estará disponible próximamente\n\nGracias por la consulta.'
        )
        # return (self.text_input.toPlainText(), 'consulta')

    def lanzar_accion(self):
        print('---> lanzar_accion')
        self.button_pressed = 'accion'
        self.accept()
        print(self.text_input.toPlainText(), 'accion')
        QMessageBox.information(
            iface.mainWindow(),
            "Petición dasolidar",
            f"Gracias por la petición.\nEsta utilidad estará disponible próximamente"
        )
        # return (self.text_input.toPlainText(), 'accion')


class PDFViewer(QMainWindow):
    def __init__(self, pdf_path):
        from PyQt5.QtWebEngineWidgets import QWebEngineView
        super().__init__()
        self.setWindowTitle("PDF Viewer")
        self.setGeometry(100, 100, 800, 600)

        self.browser = QWebEngineView()
        self.browser.setUrl(QUrl.fromLocalFile(pdf_path))

        self.setCentralWidget(self.browser)


class Dasoraster:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = iface.mapCanvas()
        self.tool_parcela = None

        settings = QSettings()
        self.radio_parcela = settings.value("dasoraster/radio_parcela", 15, type=float)
        self.consultar_circulo = settings.value("dasoraster/consultar_circulo", True, type=bool)
        self.consulta_multiple = settings.value("dasoraster/consulta_multiple", True, type=bool)
        self.lector_pdf_windows = settings.value("dasoraster/lector_pdf_windows", True, type=bool)
        self.lector_pdf_windows = True

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        print(f'plugin_dir: {self.plugin_dir}')
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Dasoraster_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Dasoraster')

        # TODO: We are going to let the user set this up in a future iteration  #  #new (mensaje de Plugin builder)
        self.toolbar = self.iface.addToolBar(u'dasoraster')  #  #new
        self.toolbar.setObjectName(u'dasoraster')  #  #new

        #print("** INITIALIZING Consulta parcela")  #  #new

        self.pluginIsActive = False  #  #new
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start_run = None
        self.first_start_consulta_rodal = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Dasoraster', message)

    def mensaje(self, mi_text='', mi_title='dasoraster', mi_showMore=None, mi_duration=15, mi_level=Qgis.Info):
        if mi_showMore is None or type(mi_showMore) != str:
            self.iface.messageBar().pushMessage(
                title=mi_title,
                text=mi_text,
                duration=mi_duration,
                level=mi_level,
            )
        else:
            self.iface.messageBar().pushMessage(
                title=mi_title,
                text=mi_text,
                showMore=mi_showMore,
                duration=mi_duration,
                level=mi_level,
            )

    def add_action(
        self,
        icon_path,
        text,
        callback,
        checkable=False,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setCheckable(checkable)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            # self.iface.addToolBarIcon(action)
            self.toolbar.addAction(action)  #  #new

        # print(u'dasoraster')  #  #new
        # print(f'action: {type(action)} {dir(action)}')  #  #new
        if add_to_menu:
            # self.iface.addPluginToRasterMenu(  #  #new
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        # Atribucion iconos de flaticon:
        # <a href="https://www.flaticon.es/iconos-gratis/meta" title="meta iconos">Meta iconos creados por Rooman12 - Flaticon</a>
        # La ruta :/plugins se establece dentro de Qgis en: Configuración -> Opciones -> Sistema
        # QGIS_PLUGINPATH = D:/_clid/dasolidar/dasolidar

        icon_path = ':/plugins/dasoraster/icon.png'
        self.action1 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n    lasFile'),
            callback=self.cargar_lasfile,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/icon_parcela.png'
        self.action2 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n   parcela'),
            callback=self.consultar_parcela,
            parent=self.iface.mainWindow(),
            checkable=True,
        )

        icon_path = ':/plugins/dasoraster/icon_rodal.png'
        self.action3 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n     rodal'),
            callback=self.consultar_rodal,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/icon_explorer.png'
        self.action4 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n lidarData'),
            callback=self.explorar_ldata,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/icon_guiaRapida.png'
        self.action5 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\nguia rápida'),
            callback=self.guia_rapida_dasolidar,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/icon_book.png'
        self.action6 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n   manual'),
            callback=self.manual_dasolidar,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/icon_star.png'
        self.action7 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n       IA'),
            callback=self.dasolidar_IA,
            parent=self.iface.mainWindow(),
        )

        icon_path = ':/plugins/dasoraster/icon_config.png'
        self.action8 = self.add_action(
            icon_path,
            text=self.tr(u'dasoraster\n  settings'),
            callback=self.dasoraster_settings,
            parent=self.iface.mainWindow(),
        )

        # Pasan a False la primera vez que se invoca cada herramienta
        self.first_start_run = True
        self.first_start_consulta_rodal = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Dasoraster'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start_run == True:
            self.first_start_run = False
            self.dlg_run = DasorasterDialog()

        # show the dialog
        self.dlg_run.show()
        # Run the dialog event loop
        result = self.dlg_run.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def manejar_clic_canvas(
            self,
            point,
            button,
            tipo_consulta='',
            raster_dataset=None,
            raster_array=None,
    ):
        self.button = button
        # Podría usar el parametro button para diferenciar entre diferentes tipos de clics si fuera necesario
        # Obtener la capa de nube de puntos

        if tipo_consulta == 'lasfile':
            layer_selec = QgsProject.instance().mapLayersByName('cargar_nubeDePuntos_LidarPNOA2')
            if not layer_selec:
                print("La capa 'cargar_nubeDePuntos_LidarPNOA2' no está cargada en el proyecto.")
                iface.messageBar().pushMessage(
                    title='dasoraster',
                    text='Para hacer la descarga de ficheros lidar de nubes de puntos (lasFiles) se requiere que la capa cargar_nubeDePuntos_LidarPNOA2 esté cargada en el proyecto.',
                    showMore=f'Se intenta cargar desde la ubicación de red: //repoarchivohm.jcyl.red/MADGMNSVPI_SCAYLEVueloLIDAR$/PNOA2/.aux/lidar_copc.gpkg|layername=copc.\nSi se carga con éxito vuelve a intentar la carga del fichero lidar (nube de puntos)',
                    duration=30,
                    level=Qgis.Warning,
                )

                # Ruta al archivo de la capa
                file_path = '//repoarchivohm.jcyl.red/MADGMNSVPI_SCAYLEVueloLIDAR$/PNOA2/.aux/lidar_copc.gpkg|layername=copc'
                # Creo la capa
                layer_selec = QgsVectorLayer(file_path, 'cargar_nubeDePuntos_LidarPNOA2', 'ogr')
                # Verifico si la capa es válida y la agrego al proyecto
                if layer_selec.isValid():
                    QgsProject.instance().addMapLayer(layer_selec)
                    print("La capa 'cargar_nubeDePuntos_LidarPNOA2' ha sido cargada.")
                else:
                    print("No se pudo cargar la capa 'cargar_nubeDePuntos_LidarPNOA2'.")
                return
            else:
                layer_selec = layer_selec[0]

        elif tipo_consulta == 'rodal':
            capa_activa_vector = False
            layer_rodales = None
            layer_activo = iface.activeLayer()  # Usar la capa activa si es vectorial
            if layer_activo is None:
                print("No hay ninguna capa activa.")
                self.mensaje(
                    f'No hay ninguna capa activa. Activa una capa vectorial para poder hacer la consulta.',
                    mi_level=Qgis.Warning)
            else:
                if layer_activo.type() == QgsMapLayer.RasterLayer:
                    nombre_capa_activa = layer_activo.name()
                    print(f'La capa activa es una capa raster (no ok): {nombre_capa_activa}')
                    self.mensaje(f'La capa activa ({nombre_capa_activa}) es ráster. Activa una capa vectorial para poder hacer la consulta.', mi_level=Qgis.Warning)
                elif layer_activo.type() == QgsMapLayer.VectorLayer:
                    nombre_capa_activa = layer_activo.name()
                    print(f'La capa activa es una capa vectorial (ok): {nombre_capa_activa}.')
                    if nombre_capa_activa == 'cargar_nubeDePuntos_LidarPNOA2':
                        self.mensaje(f'Está seleccionada la malla de ficheros Lidar ({nombre_capa_activa}); elige una capa de rodales o similar.', mi_level=Qgis.Warning)
                    else:
                        self.mensaje('Se usa la capa activa: {nombre_capa_activa}.')
                        capa_activa_vector = True
                        layer_rodales = layer_activo
                else:
                    print("La capa activa no es ni raster ni vectorial.")
                    self.mensaje(f'La capa activa no es vectorial. Activa una capa vectorial para poder hacer consultas.', mi_level = Qgis.Warning)
            layer_rodales = layer_activo
            layer_selec = layer_activo
            if not capa_activa_vector:
                return

        print(f'layer identificado: {layer_selec}')

        # Compruebo el CRS del layer_selec
        self.layer_crs = layer_selec.crs()
        print(f'CRS del layer_selec: {self.layer_crs.authid()}')
        # Defino el CRS del punto (EPSG:25830)
        point_crs = QgsCoordinateReferenceSystem('EPSG:25830')
        if self.layer_crs != point_crs:
            # Transformar el punto al CRS del layer_selec
            if self.layer_crs.authid() in ['EPSG:25829', 'EPSG:25830']:
                transform = QgsCoordinateTransform(point_crs, self.layer_crs, QgsProject.instance())
                transformed_point = transform.transform(point)
                print(f'Punto transformado: {transformed_point.x()}, {transformed_point.y()}')
            else:
                print('El layer_selec no está en EPSG:25829 ni EPSG:25830.')
            # point = QgsPointXY(X, Y)
            print('Se han convertido las coordenadas del punto (EPSG:25830) al crs del layer vectorial:')
            print(f'point original {point_crs.authid()}-> {point}')
            print(f'point transfor {self.layer_crs.authid()}-> {transformed_point}')
        else:
            transformed_point = point

        # Creo una geometría de punto (objeto de consulta)
        point_geometry = QgsGeometry.fromPointXY(transformed_point)

        # request1 = QgsFeatureRequest().setFilterGeometry(transformed_point_geometry)  # Filtrar por geometría del punto
        # selected_features1 = layer_selec.getFeatures(request1)

        # Creo un objeto de consulta
        buffer_size = 0.01
        request = QgsFeatureRequest().setFilterRect(
            QgsRectangle(transformed_point.x() - buffer_size,
                         transformed_point.y() - buffer_size,
                         transformed_point.x() + buffer_size,
                         transformed_point.y() + buffer_size)
        )
        selected_features = layer_selec.getFeatures(request)
        print(f'selected_features de tipo: {type(selected_features)}. isValid: {selected_features.isValid()}')
        # print(dir(selected_features))
        # ['close', 'compileFailed', 'compileStatus', 'isClosed', 'isValid', 'nextFeature', 'rewind']

        # print(f'Número de features en el layer_selec: {layer_selec.featureCount()}')
        # print(f'Geometría del punto: {point_geometry.asWkt()}')
        # feature_id = 21622
        # request_id = QgsFeatureRequest().setFilterFid(feature_id)
        # # Obtener la característica correspondiente
        # feature = layer_selec.getFeatures(request_id)
        # for f in feature:
        #     geometry = f.geometry()
        #     print(
        #         f'Geometría del polígono con ID {feature_id}: {geometry.asWkt()}')  # Imprime la geometría en formato WKT

        if selected_features:
            # Convertir el iterador a una lista para contar las características
            features_list = list(selected_features)
            # Contar el número de características
            num_features = len(features_list)
            print(f'Número de poligonos seleccionados-> {num_features}')
            for feature in features_list:
                if tipo_consulta == 'lasfile':
                    print(f'ID: {feature.id()}, COPC1: {feature["COPC1"]}')
                    # Obtener el valor del campo COPC1
                    copc_1_value = feature['COPC1']
                    copc_2_value = feature['COPC2']
                    copc_any_value = feature['COPC_ANY']
                    cuadrante_1_value = feature['Cuadrante']
                    cuadrante_2_value = feature['Cuadrante2']
                    copc_CE_value = feature['COPC_CE']
                    copc_NE_value = feature['COPC_NE']
                    copc_NW_value = feature['COPC_NW']
                    copc_SE_value = feature['COPC_SE']
                    copc_SW_value = feature['COPC_SW']
                    print(f'copc_value {type(copc_1_value)}: {copc_1_value}')
                    # Verifico si COPC no es NULL y el archivo existe
                    self.cargar_nube_de_puntos(
                        copc_1_value,
                        copc_2_value,
                        copc_any_value,
                        cuadrante_1_value,
                        cuadrante_2_value,
                        copc_CE_value,
                        copc_NE_value,
                        copc_NW_value,
                        copc_SE_value,
                        copc_SW_value,
                    )
                elif tipo_consulta == 'rodal':
                    print(f'Feature id: {feature.id()}')
                    self.rodal_feat = feature
                    self.obtener_volumen(
                        point,
                        self.button,
                        tipo_consulta='rodal',
                        layer_rodales=layer_rodales,
                        rodal_feat=self.rodal_feat,
                        raster_dataset=raster_dataset,
                        raster_array=raster_array,
                    )

                break  # Salir después de encontrar el primer polígono que contiene el punto
        else:
            print("No se encontró ningún polígono que contenga el punto.")

    def cargar_nube_de_puntos(
            self,
            copc_1_value,
            copc_2_value,
            copc_any_value,
            cuadrante_1_value,
            cuadrante_2_value,
            copc_CE_value,
            copc_NE_value,
            copc_NW_value,
            copc_SE_value,
            copc_SW_value,
    ):
        # Crear la capa de nube de puntos
        print(f'Existe el fichero lidar: {os.path.exists(copc_1_value)}')
        # print(f'Ruta del lasFile 0: {copc_1_value}')
        # copc_1_value1 = f'\\\\{copc_1_value}'
        # print(f'Ruta del lasFile 1: {copc_1_value1}')
        # print(os.path.exists(copc_1_value1))
        # copc_1_value2 = r'\\' + copc_1_value
        # print(f'Ruta del lasFile 2: {copc_1_value2}')
        # print(os.path.exists(copc_1_value2))
        # copc_1_value3 = r'' + copc_1_value
        # print(f'Ruta del lasFile 3: {copc_1_value3}')
        # print(os.path.exists(copc_1_value3))
        # copc_1_value4 = r'{}'.format(copc_1_value)
        # print(f'Ruta del lasFile 4: {copc_1_value4}')
        # print(os.path.exists(copc_1_value4))
        # point_cloud_layer = QgsPointCloudLayer(copc_1_value4, 'Nube de Puntos', 'las')

        verboseBase = False
        verbosePlus = False
        verboseDebug = False
        verboseWarning = True

        copcLazFile_path_name_ok = copc_1_value

        if verboseDebug:
            print(f'Cuadrante principal y secundario: {cuadrante_1_value} / {cuadrante_2_value}')
        if verbosePlus:
            if cuadrante_1_value and cuadrante_2_value:
                iface.messageBar().pushMessage(
                    f'Cuadrante principal y secundario: {cuadrante_1_value} / {cuadrante_2_value}',
                    level=Qgis.Info,
                    duration=5
                )
            elif cuadrante_1_value:
                iface.messageBar().pushMessage(
                    f'Cuadrante principal: {cuadrante_1_value}',
                    level=Qgis.Info,
                    duration=5
                )
            else:
                pass
                # iface.messageBar().pushMessage(
                #     f'Bloque fuera de CyL; se intenta buscar fichero lidar...',
                #     level=Qgis.Info,
                #     duration=5
                #     )

        if cuadrante_1_value.upper() == 'CE':
            copcLazFile_path_name_ok = copc_CE_value
        elif cuadrante_1_value.upper() == 'NE':
            if verbosePlus:
                iface.messageBar().pushMessage(
                    f'OK cuadrante: {cuadrante_1_value}',
                    level=Qgis.Info,
                    duration=5
                )
            copcLazFile_path_name_ok = copc_NE_value
        elif cuadrante_1_value.upper() == 'NW':
            copcLazFile_path_name_ok = copc_NW_value
        elif cuadrante_1_value.upper() == 'SE':
            copcLazFile_path_name_ok = copc_SE_value
        elif cuadrante_1_value.upper() == 'SW':
            copcLazFile_path_name_ok = copc_SW_value
        else:
            COPC_1 = f'COPC_{cuadrante_1_value.upper()}'
            COPC_2 = f'COPC_{cuadrante_2_value.upper()}'
            if cuadrante_1_value:
                copcLazFile_path_name_ok = COPC_1
            elif cuadrante_2_value:
                copcLazFile_path_name_ok = COPC_2
            else:
                copcLazFile_path_name1 = copc_1_value
                copcLazFile_path_name2 = copc_2_value
                copcLazFile_path_name0 = copc_any_value
                if not copcLazFile_path_name1 is None and copcLazFile_path_name1 and os.path.exists(
                        copcLazFile_path_name1):
                    copcLazFile_path_name_ok = copcLazFile_path_name1
                elif not copcLazFile_path_name2 is None and copcLazFile_path_name2 and os.path.exists(
                        copcLazFile_path_name2):
                    copcLazFile_path_name_ok = copcLazFile_path_name2
                elif not copcLazFile_path_name0 is None and copcLazFile_path_name0 and os.path.exists(
                        copcLazFile_path_name0):
                    copcLazFile_path_name_ok = copcLazFile_path_name0
                else:
                    copcLazFile_path_name_ok = None

        bloque_ya_descargado = False
        if copcLazFile_path_name_ok:
            if os.path.exists(copcLazFile_path_name_ok):
                root = QgsProject.instance().layerTreeRoot()
                lidar_group = root.findGroup('lidarDescargado')
                if lidar_group is None:
                    grupo_previo = False
                    if verbosePlus:
                        iface.messageBar().pushMessage(
                            f'Se crea el grupo lidarDescargado para contener las nubes de puntos.',
                            level=Qgis.Info,
                            duration=5
                        )
                    # lidar_group = root.addGroup('lidarDescargado')
                    lidar_group = root.insertGroup(1, 'lidarDescargado')
                else:
                    grupo_previo = True
                    if verbosePlus:
                        iface.messageBar().pushMessage(
                            f'Grupo TOC existe previamente: {str(lidar_group)}',
                            level=Qgis.Info,
                            duration=5
                        )
                lazFile_name = os.path.basename(copcLazFile_path_name_ok)
                for num, child in enumerate(root.children()):
                    if isinstance(child, QgsLayerTreeGroup) and child.name() == 'lidarDescargado':
                        bloques_descargados = child.children()
                        for num_bl, bloque in enumerate(bloques_descargados):
                            if bloque.name() == lazFile_name:
                                bloque_ya_descargado = True
                                if verboseDebug:
                                    print(f'-> {lazFile_name} ya descargado ({num_bl})')
                                if verboseWarning:
                                    iface.messageBar().pushMessage(
                                        f'Bloque Lidar ya descargado previamente: {lazFile_name}',
                                        level=Qgis.Info,
                                        duration=5
                                    )
                                break

                    if verboseDebug:
                        print(f'{num}-> group: {child.name()}')
                        # print(f'Metodos del child de type group: {dir(child)}')
                        # ['NodeGroup', 'NodeLayer', 'NodeType', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattr__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'addChildNode', 'addGroup', 'addLayer', 'addedChildren', 'blockSignals', 'checkedLayers', 'childEvent', 'children', 'clone', 'connectNotify', 'convertToGroupLayer', 'customEvent', 'customProperties', 'customProperty', 'customPropertyChanged', 'deleteLater', 'depth', 'destroyed', 'disconnect', 'disconnectNotify', 'dump', 'dumpObjectInfo', 'dumpObjectTree', 'dynamicPropertyNames', 'event', 'eventFilter', 'expandedChanged', 'findChild', 'findChildren', 'findGroup', 'findGroups', 'findLayer', 'findLayerIds', 'findLayers', 'groupLayer', 'inherits', 'insertChildNode', 'insertChildNodes', 'insertChildrenPrivate', 'insertGroup', 'insertLayer', 'installEventFilter', 'isExpanded', 'isItemVisibilityCheckedRecursive', 'isItemVisibilityUncheckedRecursive', 'isMutuallyExclusive', 'isSignalConnected', 'isVisible', 'isWidgetType', 'isWindowType', 'itemVisibilityChecked', 'killTimer', 'metaObject', 'moveToThread', 'name', 'nameChanged', 'nodeType', 'nodeVisibilityChanged', 'objectName', 'objectNameChanged', 'parent', 'property', 'pyqtConfigure', 'readChildrenFromXml', 'readCommonXml', 'readXml', 'receivers', 'removeAllChildren', 'removeChildNode', 'removeChildren', 'removeChildrenGroupWithoutLayers', 'removeChildrenPrivate', 'removeCustomProperty', 'removeEventFilter', 'removeLayer', 'removedChildren', 'resolveReferences', 'sender', 'senderSignalIndex', 'setCustomProperty', 'setExpanded', 'setGroupLayer', 'setIsMutuallyExclusive', 'setItemVisibilityChecked', 'setItemVisibilityCheckedParentRecursive', 'setItemVisibilityCheckedRecursive', 'setName', 'setObjectName', 'setParent', 'setProperty', 'signalsBlocked', 'startTimer', 'staticMetaObject', 'takeChild', 'thread', 'timerEvent', 'tr', 'updateChildVisibilityMutuallyExclusive', 'visibilityChanged', 'willAddChildren', 'willRemoveChildren', 'writeCommonXml', 'writeXml']

                if verboseDebug:
                    print(f'root: {root}')
                    print(f'children: {root.children()}')
                    for num, child in enumerate(root.children()):
                        if isinstance(child, QgsLayerTreeGroup):
                            print(f'{num}-> group: {child.name()}')
                        elif isinstance(child, QgsLayerTreeLayer):
                            print(f'{num}-> layer: {child}-> ID: {child.layerId()}')
                            print(f'{num}-> layer: {child.name()}-> ID: {child.layerId()}')
                            # print(f'Metodos del child de type layer: {dir(child)}')
                            # ['AllowSplittingLegendNodesOverMultipleColumns', 'LegendNodesSplitBehavior', 'NodeGroup', 'NodeLayer', 'NodeType', 'PreventSplittingLegendNodesOverMultipleColumns', 'UseDefaultLegendSetting', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattr__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'addedChildren', 'attachToLayer', 'blockSignals', 'checkedLayers', 'childEvent', 'children', 'clone', 'connectNotify', 'customEvent', 'customProperties', 'customProperty', 'customPropertyChanged', 'deleteLater', 'depth', 'destroyed', 'disconnect', 'disconnectNotify', 'dump', 'dumpObjectInfo', 'dumpObjectTree', 'dynamicPropertyNames', 'event', 'eventFilter', 'expandedChanged', 'findChild', 'findChildren', 'inherits', 'insertChildrenPrivate', 'installEventFilter', 'isExpanded', 'isItemVisibilityCheckedRecursive', 'isItemVisibilityUncheckedRecursive', 'isSignalConnected', 'isVisible', 'isWidgetType', 'isWindowType', 'itemVisibilityChecked', 'killTimer', 'labelExpression', 'layer', 'layerId', 'layerLoaded', 'layerWillBeUnloaded', 'legendSplitBehavior', 'metaObject', 'moveToThread', 'name', 'nameChanged', 'nodeType', 'objectName', 'objectNameChanged', 'parent', 'patchShape', 'patchSize', 'property', 'pyqtConfigure', 'readCommonXml', 'readXml', 'receivers', 'removeChildrenPrivate', 'removeCustomProperty', 'removeEventFilter', 'removedChildren', 'resolveReferences', 'sender', 'senderSignalIndex', 'setCustomProperty', 'setExpanded', 'setItemVisibilityChecked', 'setItemVisibilityCheckedParentRecursive', 'setItemVisibilityCheckedRecursive', 'setLabelExpression', 'setLegendSplitBehavior', 'setName', 'setObjectName', 'setParent', 'setPatchShape', 'setPatchSize', 'setProperty', 'setUseLayerName', 'signalsBlocked', 'startTimer', 'staticMetaObject', 'takeChild', 'thread', 'timerEvent', 'tr', 'useLayerName', 'visibilityChanged', 'willAddChildren', 'willRemoveChildren', 'writeCommonXml', 'writeXml']

                    # child0 = root.children()[0]
                    # print(f'child0: {child0}' -> type: {type(child0)}')
                    # print(f'child0 es un QgsLayerTreeLayer: {isinstance(child0, QgsLayerTreeLayer)}')
                    ## print(f'parent: {child0.parent()}') #  qgis._core.QgsLayerTreeLayer
                    # child0 = root.children()[1]
                    # print(f'child1: {child1}' -> type: {type(child1)}')
                    # print(f'child1 es un QgsLayerTreeLayer: {isinstance(child1, QgsLayerTreeLayer)}')

                if not bloque_ya_descargado:
                    if verboseBase:
                        iface.messageBar().pushMessage(
                            f'Cargando nube de puntos Lidar (copc.laz): {copcLazFile_path_name_ok}',
                            level=Qgis.Info,
                            duration=5
                        )
                    # QgsMessageLog.logMessage(f'Se va a cargar {copcLazFile_path_name_ok}')
                    pcl_LayerOptions = QgsPointCloudLayer.LayerOptions();
                    pcl_LayerOptions.skipIndexGeneration = False
                    pcl_LayerOptions.loadDefaultStyle = True
                    pcl_ = 'copc'  # 'pdal' fuerza la generacion de otro copc
                    my_pcl = QgsPointCloudLayer(copcLazFile_path_name_ok, lazFile_name, 'copc', pcl_LayerOptions)
                    # my_QgsMapLayer = QgsProject.instance().addMapLayer(my_pcl)

                    QgsProject.instance().addMapLayer(my_pcl, False)
                    my_QgsMapLayer = lidar_group.addLayer(my_pcl)
            else:
                if verboseWarning:
                    iface.messageBar().pushMessage(
                        f'Aviso: falta el bloque {copcLazFile_path_name_ok} (pendiente de copiar a \\repoarchivohm.jcyl.red). Notificar a Jose Bengoa (benmarjo@jcyl.es)',
                        level=Qgis.Warning,
                        duration=15
                    )
        else:
            if not copcLazFile_path_name1 is None and copcLazFile_path_name1:
                copcLazFile_path_name_fail = copcLazFile_path_name1
            elif not copcLazFile_path_name2 is None and copcLazFile_path_name2:
                copcLazFile_path_name_fail = copcLazFile_path_name1
            elif not copcLazFile_path_name0 is None and copcLazFile_path_name0:
                copcLazFile_path_name_fail = copcLazFile_path_name0
            else:
                copcLazFile_path_name_fail = None
            if verboseWarning:
                if not copcLazFile_path_name_fail is None:
                    # QMessageBox.warning(iface.mainWindow(), f'No se encuentra el fichero {copcLazFile_path_name_fail}')
                    iface.messageBar().pushMessage(
                        f'Bloque {copcLazFile_path_name_fail} no disponible por lo que no se ha subido a \\repoarchivohm.jcyl.red',
                        level=Qgis.Warning,
                        duration=10
                    )
                else:
                    iface.messageBar().pushMessage(
                        f'No hay fichero disponible para este bloque 2x2 km (fuera de CyL)',
                        level=Qgis.Warning,
                        duration=10
                    )
        try:
            mi_capa = QgsProject.instance().mapLayersByName('cargar_nubeDePuntos_LidarPNOA2')[0]
            iface.setActiveLayer(mi_capa)
        except:
            iface.messageBar().pushMessage(
                f'Aviso, se ha renombrado la capa cargar_nubeDePuntos_LidarPNOA2 -> Revisa código de esta acción para cambiarlo tb aqui.',
                level=Qgis.Warning,
                duration=10
            )

    def cargar_lasfile(self):
        print(f'Se ha pulsado el botón cargar_lasfile')
        print(f'dasoraster-> self.action1.isChecked() 1: {self.action1.isChecked()}')
        self.tool_lasfile = QgsMapToolEmitPoint(iface.mapCanvas())
        # Conecto la señal de clic en el canvas a la función que maneja el clic
        # self.tool_lasfile.canvasClicked.connect(self.manejar_clic_canvas)
        self.tool_lasfile.canvasClicked.connect(
            lambda event, button: self.manejar_clic_canvas(event, button, tipo_consulta='lasfile')
        )
        print(f'dasoraster-> self.action1.isChecked() 2: {self.action1.isChecked()}')
        # Establezco la herramienta de mapa actual
        iface.mapCanvas().setMapTool(self.tool_lasfile)
        print(f'dasoraster-> self.action1.isChecked() 3: {self.action1.isChecked()}')

    def consultar_parcela(self):
        print(f'dasoraster-> self.action2.isChecked() 1: {self.action2.isChecked()}')
        escala_actual = self.canvas.scale()
        print(f'dasoraster-> Escala del mapa: {escala_actual}')
        if escala_actual > 100000 / self.radio_parcela:
            print(f'dasoraster-> Escala insuficiente para ver la parcela')
            iface.messageBar().pushMessage(
                title='dasoraster',
                text=f'Amplia la escala del mapa para poder ver la parcela de {self.radio_parcela} metros de radio.',
                # showMore=f'',
                duration=10,
                level=Qgis.Info,
            )
        # if self.consulta_multiple:
        #     pass
        #     # if self.action2.isChecked():
        #     #     self.action2.setChecked(True)
        #     # else:
        #     #     self.action2.setChecked(False)
        # else:
        #     self.action2.setChecked(True)
        print(f'dasoraster-> self.action2.isChecked() 2: {self.action2.isChecked()}')
        if self.action2.isChecked():
            # self.tool_parcela = QgsMapToolEmitPoint(self.canvas)
            self.tool_parcela = CustomMapTool(
                self.canvas,
                self.radio_parcela,
                self.consultar_circulo,
                self.consulta_multiple,
            )
            # self.tool_parcela.canvasClicked.connect(self.obtener_volumen)
            self.tool_parcela.canvasClicked.connect(lambda event, button: self.obtener_volumen(event, button, tipo_consulta='parcela'))

            self.canvas.setMapTool(self.tool_parcela)
            print(f'dasoraster-> self.action2.isChecked() 3: {self.action2.isChecked()}')
            if not self.consulta_multiple:
                self.action2.setChecked(False)
        else:
            try:
                print(f"Elimino trazado de la parcela (a)")
                self.tool_parcela.rubber_band.reset(QgsWkbTypes.PolygonGeometry)
                self.canvas.unsetMapTool(self.tool_parcela)
            except Exception as mi_error:
                print(f'dasoraster-> Error:  {mi_error}')
            self.action2.setChecked(False)
            print(f'dasoraster-> self.action2.isChecked() 4: {self.action2.isChecked()}')

    def consultar_rodal(self):
        print(f'Se ha pulsado el botón consultar_rodal')
        #raster_path = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\PNOA2_2017 - 2021\variablesDasometricas\version_202410'
        raster_path = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\varios\cocina'
        raster_filename = 'dasoLidar_VolumenMadera_m3_ha.tif'
        raster_filepath = os.path.join(raster_path, raster_filename)
        print(f'Fichero de volumen: {raster_filepath}')
        print(f'Fichero disponible: {os.path.exists(raster_filepath)}')
        raster_leido_ok = False
        if os.path.exists(raster_filepath) and False:
            # Abrir el ráster usando GDAL
            iface.messageBar().pushMessage(
                title='dasoraster',
                text=f'Estamos trabajando para agilizar esta consulta. Por elmomento tendrán que esperar entre medio y un minuto mientras se lee el raster de volúmenes de Castilla y León. No pulses ninguna tecla o botón del ratón.',
                # showMore=f'',
                duration=20,
                level=Qgis.Warning,
            )
            raster_dataset = gdal.Open(raster_filepath)
            print(f'raster_dataset: {raster_dataset}')
            if raster_dataset:
                raster_band = raster_dataset.GetRasterBand(1)
                # Leer el ráster como un array de numpy
                raster_array = raster_band.ReadAsArray()
                print(f'raster_array.shape: {raster_array.shape}')
                raster_leido_ok = True
        if not raster_leido_ok:
            raster_dataset = None
            raster_array = None

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        print(f'dasoraster-> self.action3.isChecked() 1: {self.action3.isChecked()}')
        canvas = iface.mapCanvas()
        # self.tool_rodal = ConsultarRodalTool(canvas)
        self.tool_rodal = QgsMapToolEmitPoint(iface.mapCanvas())
        # Conecto la señal de clic en el canvas a la función que maneja el clic
        # self.tool_rodal.canvasClicked.connect(self.manejar_clic_canvas)
        self.tool_rodal.canvasClicked.connect(
            lambda event, button: self.manejar_clic_canvas(
                event,
                button,
                tipo_consulta='rodal',
                raster_dataset=raster_dataset,
                raster_array=raster_array,
            )
        )
        print(f'dasoraster-> self.action3.isChecked() 2: {self.action3.isChecked()}')
        # Establezco la herramienta de mapa actual
        iface.mapCanvas().setMapTool(self.tool_rodal)
        print(f'dasoraster-> self.action3.isChecked() 3: {self.action3.isChecked()}')

        # layer_rodales = canvas.currentLayer()
        # if not isinstance(layer_rodales, QgsVectorLayer):
        #     print("La capa activa no es vectorial.")
        #     return
        # print(f'dasoraster-> Vector layer: {layer_rodales.name()}')

        '''
        alternativa_usada = 2
        def on_point_emitted(point):
            print(f'dasoraster-> Se ha hecho click en (1) {point}')
            if alternativa_usada == 2:
                self.tool_rodal.canvasClicked.connect(
                    lambda event, button: self.manejar_clic_canvas(event, button, tipo_consulta='rodal')
                )
            else:
                transformed_point = point
                # Crear un objeto de consulta
                buffer_size = 0.01
                request = QgsFeatureRequest().setFilterRect(
                    QgsRectangle(transformed_point.x() - buffer_size,
                                 transformed_point.y() - buffer_size,
                                 transformed_point.x() + buffer_size,
                                 transformed_point.y() + buffer_size)
                )
                selected_features = layer_rodales.getFeatures(request)
                print(f'selected_features {type(selected_features)}: {selected_features}')

                # selected_features = [f for f in layer_rodales.getFeatures(QgsFeatureRequest().setFilterRect(
                #     canvas.mapSettings().mapToLayerCoordinates(layer_rodales, point.boundingBox())))]
                if not selected_features:
                    print("No se encontró ningún polígono en el punto clicado.")
                    return

                # Convertir el iterador a una lista para contar las características
                features_list = list(selected_features)
                # Contar el número de características
                num_features = len(features_list)
                print(f'Número de poligonos identificados-> {num_features}')

                rodal_feat = features_list[0]
                self.tool_rodal.rubberBand.setToGeometry(rodal_feat.geometry(), layer_rodales)

                # Obtener la capa raster VCC
                raster_layer = QgsProject.instance().mapLayersByName('VCC')[0]
                if not isinstance(raster_layer, QgsRasterLayer):
                    print("No se encontró la capa raster VCC.")
                    return

                # Calcular el valor medio de los píxeles del ráster en el polígono
                stats = raster_layer.dataProvider().bandStatistics(1, QgsRasterBandStats.Mean,
                                                                   rodal_feat.geometry().boundingBox())
                mean_value = stats.mean
                print(f"El valor medio de los píxeles del ráster en el polígono es: {mean_value}")

            self.tool_rodal.pointEmitted.connect(on_point_emitted)
            # self.tool_rodal.pointEmitted.connect(lambda event, button: on_point_emitted(event, button, 'rodal'))

        self.canvas.setMapTool(self.tool_rodal)
        '''

    def obtener_volumen(
            self,
            point,
            button,
            tipo_consulta='',
            layer_rodales=None,
            rodal_feat=None,
            raster_dataset=None,
            raster_array=None,
    ):
        print(f'dasoraster-> obtener_volumen-> point: {point}')
        print(f'dasoraster-> obtener_volumen-> button: {button}')
        print(f'dasoraster-> obtener_volumen-> tipo_consulta: {tipo_consulta}')

        if button == Qt.LeftButton:
            print(f"Has hecho click con el botón izdo en (b): {point}")

            if tipo_consulta == 'parcela':
                # Elimino el círculo después de hacer clic
                self.tool_parcela.rubber_band.reset(QgsWkbTypes.PolygonGeometry)

            # Parámetros de entrada
            capa_VCC_1 = 'VolumenMadera_m3_ha'
            capa_VCC_2 = 'VCC____IFNxPNOA2'
            capas_VCC = [capa_VCC_1, capa_VCC_2]
            capa_VCC_encontrada = False
            variable_medida = None
            unidad_medida = ''
            for capa_VCC in capas_VCC:
                capa_raster_vcc = QgsProject.instance().mapLayersByName(capa_VCC)
                if capa_raster_vcc:
                    capa_raster = capa_raster_vcc[0]  # Usar la capa 'VCC' si está cargada
                    variable_medida = 'Volumen'
                    unidad_medida = 'm3/ha'
                    capa_VCC_encontrada = True
                    capa_activa_raster = True
                    break
                else:
                    print(f'Capa {capa_VCC} no encontrada')

            if not capa_VCC_encontrada and tipo_consulta == 'parcela':
                capa_activa_raster = False
                layer_activo = iface.activeLayer()  # Usar la capa activa si 'VCC' no está cargada en el proyecto
                if layer_activo is None:
                    print("No hay ninguna capa activa.")
                    iface.messageBar().pushMessage(
                        title='dasoraster',
                        text=f'No se ha encontrado la capa ráster de volumen {capa_VCC_1} y no hay ninguna capa activa. Activa una capa ráster para poder hacer consultas.',
                        # showMore=f'',
                        duration=30,
                        level=Qgis.Warning,
                    )
                else:
                    if layer_activo.type() == QgsMapLayer.RasterLayer:
                        print("La capa activa es una capa raster.")
                        variable_medida = layer_activo.name()
                        print(f'Capas de volumen no encontradas; se consulta la capa activa: {variable_medida}')
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text=f'No se ha encontrado la capa ráster de volumen {capa_VCC_1}; se consulta la capa activa: {variable_medida}.',
                            # showMore=f'',
                            duration=30,
                            level=Qgis.Info,
                        )
                        capa_activa_raster = True
                        capa_raster = layer_activo
                    elif layer_activo.type() == QgsMapLayer.VectorLayer:
                        print("La capa activa es una capa vectorial.")
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text=f'No se ha encontrado la capa ráster de volumen {capa_VCC_1} y la capa activa es vectorial. Activa una capa ráster para poder hacer consultas.',
                            # showMore=f'',
                            duration=30,
                            level=Qgis.Warning,
                        )
                    else:
                        print("La capa activa no es ni raster ni vectorial.")
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text=f'No se ha encontrado la capa ráster de volumen {capa_VCC_1} y la capa activa no es ráster. Activa una capa ráster para poder hacer consultas.',
                            # showMore=f'',
                            duration=30,
                            level=Qgis.Warning,
                        )

            if not capa_VCC_encontrada and not capa_activa_raster:
                return

            x_consulta = point.x()
            y_consulta = point.y()
            if tipo_consulta == 'parcela':
                valor_medio, num_pixeles = calcular_valor_medio_parcela(
                    capa_raster,
                    x_consulta,
                    y_consulta,
                    radio_parcela=self.radio_parcela,
                    consultar_circulo=self.consultar_circulo,
                )
            elif tipo_consulta == 'rodal':
                ejecutar_consulta_beta = False
                if ejecutar_consulta_beta:
                    valor_medio, num_pixeles = calcular_valor_medio_rodal(
                        capa_raster,
                        layer_rodales,
                        rodal_feat,
                        raster_array=raster_array,
                        raster_dataset=raster_dataset,
                    )
                else:
                    valor_medio, num_pixeles = 0, 0
                # Calculo la superficie del rodal
                rodal_geom = rodal_feat.geometry()
                dest_crs = QgsCoordinateReferenceSystem("EPSG:25830")
                if dest_crs == self.layer_crs:
                    rodal_superficie = rodal_geom.area()
                else:
                    transformer = QgsCoordinateTransform(self.layer_crs, dest_crs, QgsProject.instance())
                    rodal_geom_reprojected = rodal_geom.clone()
                    rodal_geom_reprojected.transform(transformer)
                    rodal_superficie = rodal_geom_reprojected.area()
            else:
                print('Dasoraster-> Revisar este error')
            if isinstance(valor_medio, (int, float)):
                if variable_medida.upper().startswith('VOL'):
                    valor_medio = int(round(valor_medio))
                elif variable_medida.upper().startswith('BA') or variable_medida.upper().startswith('BIO'):
                    valor_medio = int(round(valor_medio))
                elif variable_medida.upper().startswith('ALT'):
                    valor_medio = round(valor_medio, 1)
                elif variable_medida.upper().startswith('COB'):
                    valor_medio = int(round(valor_medio))
                elif variable_medida.upper().startswith('AB'):
                    valor_medio = round(valor_medio, 1)
                elif variable_medida.upper().startswith('IAVC') or variable_medida.upper().startswith('CRE'):
                    valor_medio = round(valor_medio, 2)
                else:
                    valor_medio = round(valor_medio, 2)
            else:
                valor_medio = -1

            # if math.isnan(valor_medio):
            if np.isnan(valor_medio):
                iface.messageBar().pushMessage(
                    title='dasoraster',
                    text=f'La capa activa no se puede consultar. Activa una capa ráster para poder hacer consultas.',
                    # showMore=f'',
                    duration=30,
                    level=Qgis.Warning,
                )
            elif valor_medio == -1:
                QMessageBox.information(
                    self.iface.mainWindow(),
                    "Consulta dasolidar: parcela",
                    f"Parcela de r={self.radio_parcela}m\nCentro parcela: {x_consulta:0.1f}, {y_consulta:0.1f}\nValor en capa {variable_medida}: No hay pixeles con valores válidos"
                )
            else:
                if tipo_consulta == 'parcela':
                    resultado_msg = f'Parcela de radio: {self.radio_parcela}m'
                    resultado_msg += f'\nCentro parcela: {x_consulta:0.1f}, {y_consulta:0.1f}'
                    if variable_medida == 'Volumen':
                        resultado_msg += f'\nVolumen medio: {valor_medio} {unidad_medida}'
                    else:
                        resultado_msg += f'\n{variable_medida}: {valor_medio} {unidad_medida}'
                else:
                    if ejecutar_consulta_beta:
                        rodal_fid = rodal_feat.id()
                        resultado_msg = f'ATENCION: esta herramienta está en desarrollo.'
                        resultado_msg += f'\nEstá pendiente revisar si se consultan los píxeles que corresponden.'
                        resultado_msg += f'\nCuando esté revisado se quitará este mensaje.'
                        resultado_msg += f'\n\n'
                        resultado_msg += f'Identificador del polígono en la capa (id): {rodal_fid}  '
                        resultado_msg += f'\nInformación del rodal o polígono:'
                        resultado_msg += f'\n    Superficie: {rodal_superficie / 10000:0.1f} ha'
                        if variable_medida == 'Volumen':
                            valor_total = int(round(valor_medio * rodal_superficie / 10000))
                            resultado_msg += f'\n    Volumen medio: {valor_medio} {unidad_medida}'
                            resultado_msg += f'\n    Volumen total: {valor_total} m3'
                        else:
                            resultado_msg += f'\n{variable_medida}: {valor_medio} {unidad_medida}'
                        if usuario_actual.lower() == 'benmarjo':
                            resultado_msg += f'\n\nNúmero de pixeles: {num_pixeles}'
                    else:
                        rodal_fid = rodal_feat.id()
                        resultado_msg = f'Esta herramienta está en desarrollo.'
                        resultado_msg += f'\nPróximamente incluirá el cálculo del volumen de madera'
                        resultado_msg += f'\nestimado para el rodal en el que se ha hecho click.'
                        resultado_msg += f'\nPor el momento se ofrece solo esta información:'
                        resultado_msg += f'\n\n'
                        resultado_msg += f'Identificador del polígono en la capa (id): {rodal_fid}  '
                        resultado_msg += f'\nInformación del rodal o polígono:'
                        resultado_msg += f'\n    Superficie: {rodal_superficie / 10000:0.1f} ha'
                        if variable_medida == 'Volumen':
                            valor_total = int(round(valor_medio * rodal_superficie / 10000))
                            resultado_msg += f'\n    Volumen medio: XXX {unidad_medida}'
                            resultado_msg += f'\n    Volumen total: XXX m3'
                        else:
                            resultado_msg += f'\n{variable_medida}: XXX {unidad_medida}'
                QMessageBox.information(
                    self.iface.mainWindow(),
                    f'Consulta dasolidar: {tipo_consulta}',
                    resultado_msg,
                )
            if tipo_consulta == 'parcela':
                if self.consulta_multiple:
                    # self.action2.setChecked(True)
                    if self.action2.isChecked():
                        print(f"Se lanza de nuevo la herramienta (b)")
                        self.consultar_parcela()
                    print(f'dasoraster-> self.action2.isChecked() 5a: {self.action2.isChecked()}')
                else:
                    print(f"Elimino trazado de la parcela (b)")
                    # Elimino el círculo después de hacer clic
                    self.action2.setChecked(False)
                    self.canvas.unsetMapTool(self.tool_parcela)
                    print(f'dasoraster-> self.action2.isChecked() 5b: {self.action2.isChecked()}')

    def mostrar_dialogo_compilado(self):
        if self.first_start_consulta_rodal == True:
            self.first_start_consulta_rodal = False
            self.dlg_consulta_rodal = DasorasterDialog_consulta_rodal()
        try:
            # show the dialog
            self.dlg_consulta_rodal.show()
            # Run the dialog event loop
            result = self.dlg_consulta_rodal.exec_()
        except Exception as mi_error:
            print(f'dasoraster-> Error:  {mi_error}')

    def explorar_ldata(self):
        print('---> explorar_ldata')
        ldata_path = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$'
        if os.path.exists(ldata_path):
            print(f'Directorio disponible ok: {ldata_path}')
        else:
            print(f'Directorio no accesible: {ldata_path}')
            iface.messageBar().pushMessage(
                title='dasoraster',
                text=f'No hay acceso a la unidad de red {ldata_path}.',
                showMore=f'Esto puede ser debido a:\n  1. El usuario {usuario_actual} no está dado de alta en la lista de usuarios del proyecto dasolidar\n  2. Se está trabajando fuera de la intranet de la Junta de Castilla y León.\n\nEste recurso solo está disponible para los usuarios del proyecto dasolidar con acceso a la intranet de la Junta de Castilla y León',
                duration=30,
                level=Qgis.Warning,
            )
            return
        rpta_ok = subprocess.Popen(f'explorer "{ldata_path}"')
        # print(f'Rpta de explorar_ldata: {type(rpta_ok)}')  #  <class 'subprocess.Popen'>
        print(f'Directorio explorado: {rpta_ok.args}')
        print(f'Respuesta: {rpta_ok.returncode}')

    def guia_rapida_dasolidar(self):
        dialog = VentanaBienvenidaGuiaRapida()
        if dialog.ok:
            rpta_ok = dialog.exec_()
        # if rpta_ok == QDialog.Accepted:
        #     print('OK presionado')
        #     if dialog.checkbox.isChecked():
        #         print('Seguir mostrando la ventana de bienvenida')
        #         config_class.dl_mostrar_ventana_bienvenida = True
        #         config_class.dl_mostrar_message_bienvenida = True
        #     else:
        #         print('No mostrar la ventana de bienvenida')
        #         config_class.dl_mostrar_ventana_bienvenida = False
        #         config_class.dl_mostrar_message_bienvenida = True
        #     mi_config.setValue('dasolidar/mostrar_ventana_bienvenida', config_class.dl_mostrar_ventana_bienvenida)
        #     mi_config.setValue('dasolidar/mostrar_message_bienvenida', config_class.dl_mostrar_message_bienvenida)
        #     # print(f'dl_mostrar_ventana_bienvenida 3: ({type(config_class.dl_mostrar_ventana_bienvenida)}) {config_class.dl_mostrar_ventana_bienvenida}')
        # else:
        #     print('Cancelar presionado')

    def manual_dasolidar(self):
        ruta_manual_local = os.path.dirname(__file__)
        ruta_manual_red = r'\\repoarchivohm.jcyl.red\MADGMNSVPI_SCAYLEVueloLIDAR$\dasoLidar\doc\ayudaDasolidar'
        rutas_manual = [ruta_manual_red, ruta_manual_local]
        for ruta_manual in rutas_manual:
            pdf_path = os.path.join(ruta_manual, 'manualDasoLidar.pdf')
            if os.path.exists(pdf_path):
                print(f'pdf_path_ok: {pdf_path}')
                if self.lector_pdf_windows:
                    if platform.system() == 'Windows':
                        os.startfile(pdf_path)
                else:
                    try:
                        from PyQt5.QtWebEngineWidgets import QWebEngineView
                        print("PyQtWebEngine está instalado.")
                    except ImportError:
                        print("PyQtWebEngine no está instalado.")
                        iface.messageBar().pushMessage(
                            title='dasoraster',
                            text='Solo está disponible la opción de lector pdf predeterminado de Windows. No necesitas hacer nada, ya hemos activado por tí esa opción en [settingd] -> Vuelve a intentarlo.',
                            showMore=f'PyQtWebEngine no está instalado: para mostrar el manual dasolidar sin usar la app predeterminada de Windows a los pdf se requiere el paquete PyQtWebEngine.',
                            duration=30,
                            level=Qgis.Warning,
                        )
                        self.lector_pdf_windows = True
                        QSettings().setValue("dasoraster/lector_pdf_windows", self.lector_pdf_windows)
                        # !pip install PyQtWebEngine
                        return
                    app = QApplication(sys.argv)
                    viewer = PDFViewer(pdf_path)
                    viewer.show()
                    sys.exit(app.exec_())
                break
            else:
                print(f'Fichero no disponible: {pdf_path}')

    def dasolidar_IA(self):
        dialog = VentanaAsistente(
            parent=None,
            botones_disponibles='consulta_ejecucion',
        )
        rpta_ok = dialog.exec_()
        print(f'Rpta de mostrar_asistente: {rpta_ok}')
        if rpta_ok == QDialog.Accepted:
            consulta_usuario = dialog.get_text()
            boton_pulsado = dialog.button_pressed
            print('Texto de consulta o petición:', consulta_usuario)
            print('Botón pulsado:', boton_pulsado)
        else:
            print('Consulta o petición canceladas')

    def dasoraster_settings(self):
        dict_settings = {}
        dict_settings['radio_parcela'] = self.radio_parcela
        dict_settings['consultar_circulo'] = self.consultar_circulo
        dict_settings['consulta_multiple'] = self.consulta_multiple
        dict_settings['lector_pdf_windows'] = self.lector_pdf_windows
        dialog = SettingsDialog(dict_settings)
        if dialog.exec_():
            # Actualizo los valores de la clase con los nuevos valores
            settings = QSettings()
            self.radio_parcela = settings.value("dasoraster/radio_parcela", type=float)
            self.consultar_circulo = settings.value("dasoraster/consultar_circulo", type=bool)
            self.consulta_multiple = settings.value("dasoraster/consulta_multiple", type=bool)
            self.lector_pdf_windows = settings.value("dasoraster/lector_pdf_windows", type=bool)


# ==============================================================================
class CustomMapTool(QgsMapToolEmitPoint):
    def __init__(self, canvas, radio_parcela, consultar_circulo, consulta_multiple):
        super().__init__(canvas)
        self.canvas = canvas
        self.rubber_band = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rubber_band.setColor(QColor(255, 0, 0, 100))
        self.rubber_band.setWidth(1)
        self.setCursor()
        self.radio_parcela = radio_parcela
        self.consultar_circulo = consultar_circulo
        self.consulta_multiple = consulta_multiple

    def setCursor(self):
        pixmap = QPixmap(32, 32)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setPen(QPen(Qt.black, 2))
        painter.drawLine(16, 0, 16, 32)
        painter.drawLine(0, 16, 32, 16)
        painter.end()
        self.cursor = QCursor(pixmap)
        self.canvas.setCursor(self.cursor)

    def canvasMoveEvent(self, event):
        point = self.toMapCoordinates(event.pos())
        self.rubber_band.reset(QgsWkbTypes.PolygonGeometry)
        if self.consultar_circulo:
            self.draw_circle(point)
        else:
            self.draw_square(point)

    def draw_circle(self, point):
        circle = QgsGeometry.fromPointXY(point).buffer(self.radio_parcela, 50)
        self.rubber_band.setToGeometry(circle, QgsProject.instance().crs())
        # circle_item = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        # circle_item.setToGeometry(circle, QgsProject.instance().crs())
        # circle_item.setColor(QColor(255, 0, 0, 100))
        # circle_item.setWidth(1)

    def draw_square(self, point):
        semi_lado = self.radio_parcela
        points = [
            QgsPointXY(point.x() - semi_lado, point.y() - semi_lado),
            QgsPointXY(point.x() + semi_lado, point.y() - semi_lado),
            QgsPointXY(point.x() + semi_lado, point.y() + semi_lado),
            QgsPointXY(point.x() - semi_lado, point.y() + semi_lado),
            QgsPointXY(point.x() - semi_lado, point.y() - semi_lado)  # Close the square
        ]
        square = QgsGeometry.fromPolygonXY([points])
        self.rubber_band.setToGeometry(square, QgsProject.instance().crs())

    def canvasReleaseEvent(self, event):
        point = self.toMapCoordinates(event.pos())
        print(f"Has hecho click en (a): {point}")
        if self.consulta_multiple:
            print(f"Se lanza de nuevo la herramienta")
            # self.consultar_parcela()
        else:
            print(f"Elimino trazado de la parcela")
            # Elimino el círculo después de hacer clic
            self.rubber_band.reset(QgsWkbTypes.PolygonGeometry)

# https://qgis.org/pyqgis/master/gui/QgsMapToolIdentifyFeature.html
# Clase: QgsMapToolIdentifyFeature
# Methods: setLayer
#     change the layer used by the map tool to identify
# Signals: featureIdentified
#     Emitted when a feature has been identified by its id.

# ==============================================================================
# class ConsultarRodalTool(QgsMapToolIdentifyFeature):
class ConsultarRodalTool(QgsMapToolEmitPoint):
    pointEmitted = pyqtSignal(object)

    def __init__(self, canvas):
        super().__init__(canvas)
        self.canvas = canvas
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rubberBand.setColor(Qt.red)
        self.rubberBand.setWidth(2)
        print(f'dasoraster-> Instanciando ConsultarRodalTool')
        self.setCursor()

    def activate(self):
        self.canvas.setCursor(QCursor(Qt.CrossCursor))
        super().activate()

    def setCursor(self):
        pixmap = QPixmap(32, 32)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setPen(QPen(Qt.black, 2))
        painter.drawLine(16, 0, 16, 32)
        painter.drawLine(0, 16, 32, 16)
        painter.end()
        self.cursor = QCursor(pixmap)
        self.canvas.setCursor(self.cursor)

    def canvasReleaseEvent(self, event):
        point = self.toMapCoordinates(event.pos())
        print(f'dasoraster-> Se ha hecho click en (2) {point}')
        self.pointEmitted.emit(point)

    def canvasReleaseEvent_sin_uso(self, event):
        layer = self.canvas.currentLayer()
        if not isinstance(layer, QgsVectorLayer):
            print("La capa activa no es vectorial.")
            return
        print(f'dasoraster-> Vector layer: {layer.name()}')

        point = self.toMapCoordinates(event.pos())
        print(f'dasoraster-> Se ha hecho click en (0) {point}')

        # self.setLayer(layer)
        # features_identificadas = self.featureIdentified()
        # features_identificadas = self.identify(point, [layer], QgsMapToolIdentify.TopDownStopAtFirst)
        # features_identificadas = self.identify(point, [layer])
        # features_identificadas = self.identifyVectorLayer(layer, point, QgsMapToolIdentifyFeature.LayerSelection)
        features_identificadas = self.identify(point, [layer], QgsMapToolIdentifyFeature.LayerSelection)

        if not features_identificadas:
            print("No se encontró ningún polígono en el punto clicado.")
            return

        # Convertir el iterador a una lista para contar las características
        features_list = list(features_identificadas)
        # Contar el número de características
        num_features = len(features_list)
        print(f'Número de poligonos identificados-> {num_features}')

        # for feature in features_list:
        feature = features_list[0].mFeature
        self.rubberBand.setToGeometry(feature.geometry(), layer)

        # Obtener la capa raster VolumenMadera_m3_ha
        raster_layer = QgsProject.instance().mapLayersByName('VolumenMadera_m3_ha')[0]
        if not isinstance(raster_layer, QgsRasterLayer):
            print("No se encontró la capa raster VolumenMadera_m3_ha.")
            return

        print(f'dasoraster-> Raster layer: {raster_layer.name()}')

        # Calcular el valor medio de los píxeles del ráster en el polígono
        stats = raster_layer.dataProvider().bandStatistics(1, QgsRasterBandStats.Mean, feature.geometry().boundingBox())
        mean_value = stats.mean
        print(f"El valor medio de los píxeles del ráster en el polígono es: {mean_value}")



# ==============================================================================
class SettingsDialog(QDialog):
    # def __init__(self, parent=None):
    def __init__(self, dict_settings, parent=None):
        super(SettingsDialog, self).__init__(parent)

        radio_parcela = dict_settings['radio_parcela']
        consultar_circulo = dict_settings['consultar_circulo']
        consulta_multiple = dict_settings['consulta_multiple']
        lector_pdf_windows = dict_settings['lector_pdf_windows']

        self.setWindowTitle("Configuración")

        # Creo el layout
        layout = QVBoxLayout()
        form_layout = QFormLayout()

        # Creo los widgets
        self.radio_parcela_input = QLineEdit()
        self.radio_parcela_input.setText(str(radio_parcela))
        self.consultar_circulo_input = QCheckBox()
        self.consultar_circulo_input.setChecked(consultar_circulo)
        self.consulta_multiple_input = QCheckBox()
        self.consulta_multiple_input.setChecked(consulta_multiple)
        self.lector_pdf_windows_input = QCheckBox()
        self.lector_pdf_windows_input.setChecked(lector_pdf_windows)

        # Añado widgets al form layout
        form_layout.addRow("Radio parcela (m):", self.radio_parcela_input)
        form_layout.addRow("Parcela circular:", self.consultar_circulo_input)
        form_layout.addRow("Consulta multi-parcela:", self.consulta_multiple_input)
        form_layout.addRow("Usar lector pdf Windows:", self.lector_pdf_windows_input)

        # Añado form layout al layout principal
        layout.addLayout(form_layout)

        # Creo botones
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Cancelar")

        # Añado botones al layout principal
        layout.addWidget(self.ok_button)
        layout.addWidget(self.cancel_button)

        # Conecto señales y slots
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        # Establezco el layout del diálogo
        self.setLayout(layout)

    def accept(self):
        # Guardo los valores en QSettings
        settings = QSettings()
        settings.setValue("dasoraster/radio_parcela", float(self.radio_parcela_input.text()))
        settings.setValue("dasoraster/consultar_circulo", self.consultar_circulo_input.isChecked())
        settings.setValue("dasoraster/consulta_multiple", self.consulta_multiple_input.isChecked())
        settings.setValue("dasoraster/lector_pdf_windows", self.lector_pdf_windows_input.isChecked())

        # Llamo al método accept del QDialog
        super(SettingsDialog, self).accept()



# ==============================================================================

def foo():
    pass
